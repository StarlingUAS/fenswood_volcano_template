{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Fenswood Volcano Template Tutorials \u00b6 Introduction \u00b6 This repository provides a template and tutorial to get you started writing code and running simulations for the Group Project in Aerial Robotics, based on the Fenswood Volcano scenario. In this tutorial, you will learn how to write code in Python to interface with the (simulated) drone using ROS. In particular, you will learn the newer ROS2 methods, which offer improved security and scalability. On the way, you will learn the fundamentals of controlling a drone through a standard autopilot. You will also need to do little bits of Linux and Docker 'magic' to make the application work. You are not expected to master these aspects: ask for help if they cause problems. The primary learning objectives here are drone control, Python and ROS. In the examples, a drone takes off, moves to a target location, and then flies home. In the later perception example, some very basic information is gathered from its camera image. Together, these examples give you all the building blocks you will need to carry out the project. Once you are more confident with writing writing code in Python and controlling your drone in ROS, the advanced tutorial will then slowly start peeling back the layers of the Linux and Docker 'magic' which you have been using. You are not expected to master these aspects . These advanced topics will give you a greater understanding of the underlying system if you wish to achieve more complex behaviours. This tutorial is part 2 of two tutorials written for the Fenswood Scenario Basics of Linux, ROS and Docker on this site (starting here): https://starlinguas.github.io/FenswoodScenario/tutorials/fenswood_scenario/ Also includes simulator specific documentation. Fenswood Volcano Template Tutorials where you will learn how to create and build your controller https://starlinguas.github.io/fenswood_volcano_template/ How to use this tutorial \u00b6 Inspired by the minimal ROS2 examples , this tutorial takes you through several iterations of code with almost the same functionality. A full working example is provided in each case with a detailed description of the code. The section below shows the contents and learning obectives for each stage of the tutorial. If you are really confident on ROS concepts and object-oriented programming in Python, go straight to the ROS timer tutorial. Otherwise, you are advised to simply work through from start to finish but you might find some stages easier than others, depending on your past experience. Each tutorial stage comes with some exercises for you to add to the code yourself. To test your solutions, the simulation is always started using docker-compose [-f <some-file>] up --build and then stopped using Ctrl+C . Use the terminal window output, foxglove studio, or the Docker Desktop (Windows and Mac only) to inspect the results. Don't forget the --build . Otherwise, your changes don't get built into the simulation, and you're just running the same code over and over. There are countless links in the tutorials. These provide extra information, background and sources, but are not essential reading. Follow them if you are interested, but do not feel compelled to digest each one. Contents \u00b6 Tutorial \u00b6 Getting started Learn how to install and run the simulation Drone control Learn the key steps in flying a drone using Ardupilot and ROS. Old school Learn how to control the drone using ROS from Python A simple class Learn how to use a Python class as a better drone controller A better, more modular class Learn how to use a more modular programming approach to improve your Python class Finite state machine Learn how to use a finite state machine as your decision-making engine ROS timer Learn how to use ROS2 built-in timer to manage the finite state machine execution Perception Learn how to add a second process or 'node' to the ROS application (ROS) Learn how to install a third-party library in the Volcano application (Docker) Learn how to access the camera image ready for vision processing (OpenCV) Advanced Tutorial \u00b6 Starling Learn what exactly Starling is and how to configure elements of it. Developing a ROS package Learn about ROS packages and how changes get incorporated Learn how to write multi-file ros nodes Containerising your controller Learn what a container is, why we use them and how to run your application as a container. Local development and testing Learn how to make your development more efficient by splitting the simulator and controller Learn how to use Makefiles in your development","title":"Fenswood Volcano Template Tutorials"},{"location":"#fenswood-volcano-template-tutorials","text":"","title":"Fenswood Volcano Template Tutorials"},{"location":"#introduction","text":"This repository provides a template and tutorial to get you started writing code and running simulations for the Group Project in Aerial Robotics, based on the Fenswood Volcano scenario. In this tutorial, you will learn how to write code in Python to interface with the (simulated) drone using ROS. In particular, you will learn the newer ROS2 methods, which offer improved security and scalability. On the way, you will learn the fundamentals of controlling a drone through a standard autopilot. You will also need to do little bits of Linux and Docker 'magic' to make the application work. You are not expected to master these aspects: ask for help if they cause problems. The primary learning objectives here are drone control, Python and ROS. In the examples, a drone takes off, moves to a target location, and then flies home. In the later perception example, some very basic information is gathered from its camera image. Together, these examples give you all the building blocks you will need to carry out the project. Once you are more confident with writing writing code in Python and controlling your drone in ROS, the advanced tutorial will then slowly start peeling back the layers of the Linux and Docker 'magic' which you have been using. You are not expected to master these aspects . These advanced topics will give you a greater understanding of the underlying system if you wish to achieve more complex behaviours. This tutorial is part 2 of two tutorials written for the Fenswood Scenario Basics of Linux, ROS and Docker on this site (starting here): https://starlinguas.github.io/FenswoodScenario/tutorials/fenswood_scenario/ Also includes simulator specific documentation. Fenswood Volcano Template Tutorials where you will learn how to create and build your controller https://starlinguas.github.io/fenswood_volcano_template/","title":"Introduction"},{"location":"#how-to-use-this-tutorial","text":"Inspired by the minimal ROS2 examples , this tutorial takes you through several iterations of code with almost the same functionality. A full working example is provided in each case with a detailed description of the code. The section below shows the contents and learning obectives for each stage of the tutorial. If you are really confident on ROS concepts and object-oriented programming in Python, go straight to the ROS timer tutorial. Otherwise, you are advised to simply work through from start to finish but you might find some stages easier than others, depending on your past experience. Each tutorial stage comes with some exercises for you to add to the code yourself. To test your solutions, the simulation is always started using docker-compose [-f <some-file>] up --build and then stopped using Ctrl+C . Use the terminal window output, foxglove studio, or the Docker Desktop (Windows and Mac only) to inspect the results. Don't forget the --build . Otherwise, your changes don't get built into the simulation, and you're just running the same code over and over. There are countless links in the tutorials. These provide extra information, background and sources, but are not essential reading. Follow them if you are interested, but do not feel compelled to digest each one.","title":"How to use this tutorial"},{"location":"#contents","text":"","title":"Contents"},{"location":"#tutorial","text":"Getting started Learn how to install and run the simulation Drone control Learn the key steps in flying a drone using Ardupilot and ROS. Old school Learn how to control the drone using ROS from Python A simple class Learn how to use a Python class as a better drone controller A better, more modular class Learn how to use a more modular programming approach to improve your Python class Finite state machine Learn how to use a finite state machine as your decision-making engine ROS timer Learn how to use ROS2 built-in timer to manage the finite state machine execution Perception Learn how to add a second process or 'node' to the ROS application (ROS) Learn how to install a third-party library in the Volcano application (Docker) Learn how to access the camera image ready for vision processing (OpenCV)","title":"Tutorial"},{"location":"#advanced-tutorial","text":"Starling Learn what exactly Starling is and how to configure elements of it. Developing a ROS package Learn about ROS packages and how changes get incorporated Learn how to write multi-file ros nodes Containerising your controller Learn what a container is, why we use them and how to run your application as a container. Local development and testing Learn how to make your development more efficient by splitting the simulator and controller Learn how to use Makefiles in your development","title":"Advanced Tutorial"},{"location":"advanced/containers/","text":"Packaging up your controller into a container \u00b6 Packaging up your controller into a container Containers What is Containerisation and Docker Docker Concepts in more detail Docker and Starling Packaging your controller Anatomy of a Docker Container Writing a Dockerfile Building a Docker container Exercises Back to tutorial contents Containers \u00b6 As you may have guessed, Starling heavily makes use of \"docker containers\" for the encapsulation and execution of our applications. In fact, throughout these tutorials, we have constantly been referring to \"application containers\", \"containers\", \"docker container\" and so on. So far we have simply asked you to consider them as mini operating systems or virtual machines. But perhaps now is a good time to go into a little more detail. What is Containerisation and Docker \u00b6 It would be nice to give a computer - any computer with an internet connection - a short string of ASCII characters (say via a keyboard), press enter, and return to see some program running. Forget about where the program was built or what software you happened to be running at the time (this can be checked, and we can fetch the necessary dependencies). Sounds simple, right? In fact, this is an engineering task that has taken thousands of the world\u2019s brightest developers many decades to implement. Thanks to the magic of container technology we now can run any Linux program on almost any networked device on the planet, as is. All of the environment preparation, installation and configuration steps can be automated from start to finish. Depending on how much network bandwidth you have, it might take a while, but that\u2019s all right. All you need to do is type the string correctly. Docker is one very widely used example of containerisation technology, and the one we make use of in Starling. They provide a large number of tools and programs to help us contain, develop, test and deploy our containers to the real world. If you followed the getting started , you should hopefully have done the full docker install. If not, you can run the following command from a linux command line to install basic docker. curl -sSL https://get.docker.com/ | sh Docker Concepts in more detail \u00b6 Adapted from Docker Resources A container is a standard unit of software that packages up code and all its dependencies so the application runs quickly and reliably from one computing environment to another. A Docker container image is a lightweight, standalone, executable package of software that includes everything needed to run an application: code, runtime, system tools, system libraries and settings. Container images become containers at runtime and in the case of Docker containers \u2013 images become containers when they run on Docker Engine. Available for both Linux and Windows-based applications, containerized software will always run the same, regardless of the infrastructure. Containers isolate software from its environment and ensure that it works uniformly despite differences for instance between development and staging. Containers are Standard (can run anywhere), Lightweight (Share low level machine system and not the whole Operating System) and Secure (Each application is as isolated as possible). For us this also translates to providing Reproduceable and Reusable systems. On the left, Containers are an abstraction at the app layer that packages code and dependencies together. Multiple containers can run on the same machine and share the OS kernel with other containers, each running as isolated processes in user space. Containers take up less space than VMs (container images are typically tens of MBs in size), can handle more applications and require fewer VMs and Operating systems. On the right, Virtual machines (VMs) are an abstraction of physical hardware turning one server into many servers. The hypervisor allows multiple VMs to run on a single machine. Each VM includes a full copy of an operating system, the application, necessary binaries and libraries \u2013 taking up tens of GBs. VMs can also be slow to boot. Docker and Starling \u00b6 Then to connect things back to Starling - The purpose of Starling is to allow you to quickly and easily install and run a UAV simulation within a simulated environment, so that you can test your developed controllers against a semi-realistic scenario, to then test in the real world Therefore Starling is a set of pre-built programs/executables, some of which are pre-configured for the following: Running a Physics Simulation with Visualisation Running the Drone autopilot control software locally (a.k.a Software In The Loop or SITL) Running the interface between Mavlink and other protocols such as the Robot Operating System (ROS) And many others... These pre-built containers are all available in the StarlingUAS repository on github and on Docker Hub. Packaging your controller \u00b6 Anatomy of a Docker Container \u00b6 From the user's perspective, a Docker image / container is simply the operating system and essentials - such as installationas, application code, and dependencies. In Starling we create Docker images by using a Dockerfile - a plain text file that provides the specifications for creating a Docker image. See this post for more details In Starling, a controller Docker container is based on the following image template uobflightlabstarling/starling-controller-base:latest It is based on the Ubuntu 20.04 distribution (focal) It has ROS2 FOXY installed in it It has mavros_msgs and a number of other related packages already installed There exists a folder in the root directory /ros_ws which will contain all user space code. This is the ROS2 workspace. Your application source goes into /ros_ws/src . Writing a Dockerfile \u00b6 The Dockerfile which specifies your controller is at fenswood_drone_controller/Dockerfile and should look something like the following: 1. FROM uobflightlabstarling/starling-controller-base:latest 2. 3. RUN apt update 4. RUN apt-get install -y ros-foxy-vision-opencv python3-pip 5. RUN pip3 install opencv-python 6. 7. COPY . /ros_ws/src/fenswood_drone_controller 8. 9. RUN . /ros_ws/install/setup.sh \\ && colcon build 10. 11. CMD [ \"ros2\", \"launch\", \"fenswood_drone_controller\", \"controller.launch.xml\" ] When you build a Dockerfile, Docker reads and executes the commands specified line by line. This is similar to when you have a blank linux distribution and start typing instructions to install libraries and applications. Breaking it down line by line: 1. FROM uobflightlabstarling/starling-controller-base:latest This line (the FROM ) tells the builder the Docker image which we should build upon or augment. In this case we are building your application on top of the controller base image. 3. RUN apt update 4. RUN apt-get install -y ros-foxy-vision-opencv python3-pip 5. RUN pip3 install opencv-python Here we are installing the key libraries using apt-get and pip3 , the package managers for ubuntu and python respectively. These libraries are not included in the base image, so we need to add them before your application can run. If you find you need any other dependencies, you will need to install them here. The RUN command tells Docker to simply run the given command inside the container. Simply installing the dependencies on your local machine will do nothing inside the container. 7. COPY . /ros_ws/src/fenswood_drone_controller This COPY command then takes everything locally in the same directory as the Dockerfile (specified using dot . ) and copies it into the container at the path given. This is a normal way of getting files from your local system into the container. Note: Copy will literally copy the state of all of your files at the time of building. Any new changes to your files will not be reflected in the container until your build again. However, there are ways to allow you to do live editing inside the container - see bind mounts - we will need these if you want to get data out. 9. RUN . /ros_ws/install/setup.sh \\ && colcon build This line then compiles your ros nodes. The first command . /ros_ws/install/setup.sh sources ROS2. That means it makes the ROS2 command line commands available for the terminal to use. The second command colcon build . Then builds all of the ros nodes it can find in the src directory. This is the step which builds your container. Note: All RUN commands are run inside the /ros_ws folder. This was specified in the parent image. So colcon build is run inside /ros_ws and therefore looks for ros packages inside /ros_ws/src 11. CMD [ \"ros2\", \"launch\", \"fenswood_drone_controller\", \"controller.launch.xml\" ] Finally, the CMD specifies the command that the Docker image will run when run. Here, by default, the docker contaienr will launch the controller.launch.xml launch file from within fenswood_drone_controller Note: This command is run inside the container using the bash shell. There is a hidden file called /ros_entrypoint.sh which is sourced just before running the command. This entrypoint file sources ros and the /ros_ws workspace so bash knows about your local ros nodes. Note: this CMD can and often is over-ridden. See any of the docker-compose files where we run one of the other controllers. Building a Docker container \u00b6 Now we have the Dockerfile, the only thing left to do is build it. There are 2 ways: Using the Docker command line tool from the root of this repository. This will create a new docker image called my_application which you can then run. docker build -t my_application fenswood_drone_controller docker run my_application Using Docker-Compose, which is how we've been doing it for the majority of this tutorial. In the docker-compose.yml we specify the relative path to the Dockerfile and docker-compose will build the application for us. controller: build: ../fenswood_drone_controller Note: There is a 3rd method which uses docker buildx which you might see in some of the other Starling projects. This is needed in order to build containers for other computer architectures - such as for the raspberry pi which runs on an Arm64 chip (aka cross-platform). We may cover this at a later date. Note: The build process uses caching to speed up. The Dockerfile commands are run in order so if an earlier command has not changed, or it detects no changes, it will only rebuild the new stuff. Exercises \u00b6 Add a new dependency into your code (e.g. use the scipy library for something small). Try and add it to your Dockerfile and rebuild. Change the CMD line to run a different controller launch file by default. Back to tutorial contents","title":"3. Packaging your controller into a container"},{"location":"advanced/containers/#packaging-up-your-controller-into-a-container","text":"Packaging up your controller into a container Containers What is Containerisation and Docker Docker Concepts in more detail Docker and Starling Packaging your controller Anatomy of a Docker Container Writing a Dockerfile Building a Docker container Exercises Back to tutorial contents","title":"Packaging up your controller into a container"},{"location":"advanced/containers/#containers","text":"As you may have guessed, Starling heavily makes use of \"docker containers\" for the encapsulation and execution of our applications. In fact, throughout these tutorials, we have constantly been referring to \"application containers\", \"containers\", \"docker container\" and so on. So far we have simply asked you to consider them as mini operating systems or virtual machines. But perhaps now is a good time to go into a little more detail.","title":"Containers"},{"location":"advanced/containers/#what-is-containerisation-and-docker","text":"It would be nice to give a computer - any computer with an internet connection - a short string of ASCII characters (say via a keyboard), press enter, and return to see some program running. Forget about where the program was built or what software you happened to be running at the time (this can be checked, and we can fetch the necessary dependencies). Sounds simple, right? In fact, this is an engineering task that has taken thousands of the world\u2019s brightest developers many decades to implement. Thanks to the magic of container technology we now can run any Linux program on almost any networked device on the planet, as is. All of the environment preparation, installation and configuration steps can be automated from start to finish. Depending on how much network bandwidth you have, it might take a while, but that\u2019s all right. All you need to do is type the string correctly. Docker is one very widely used example of containerisation technology, and the one we make use of in Starling. They provide a large number of tools and programs to help us contain, develop, test and deploy our containers to the real world. If you followed the getting started , you should hopefully have done the full docker install. If not, you can run the following command from a linux command line to install basic docker. curl -sSL https://get.docker.com/ | sh","title":"What is Containerisation and Docker"},{"location":"advanced/containers/#docker-concepts-in-more-detail","text":"Adapted from Docker Resources A container is a standard unit of software that packages up code and all its dependencies so the application runs quickly and reliably from one computing environment to another. A Docker container image is a lightweight, standalone, executable package of software that includes everything needed to run an application: code, runtime, system tools, system libraries and settings. Container images become containers at runtime and in the case of Docker containers \u2013 images become containers when they run on Docker Engine. Available for both Linux and Windows-based applications, containerized software will always run the same, regardless of the infrastructure. Containers isolate software from its environment and ensure that it works uniformly despite differences for instance between development and staging. Containers are Standard (can run anywhere), Lightweight (Share low level machine system and not the whole Operating System) and Secure (Each application is as isolated as possible). For us this also translates to providing Reproduceable and Reusable systems. On the left, Containers are an abstraction at the app layer that packages code and dependencies together. Multiple containers can run on the same machine and share the OS kernel with other containers, each running as isolated processes in user space. Containers take up less space than VMs (container images are typically tens of MBs in size), can handle more applications and require fewer VMs and Operating systems. On the right, Virtual machines (VMs) are an abstraction of physical hardware turning one server into many servers. The hypervisor allows multiple VMs to run on a single machine. Each VM includes a full copy of an operating system, the application, necessary binaries and libraries \u2013 taking up tens of GBs. VMs can also be slow to boot.","title":"Docker Concepts in more detail"},{"location":"advanced/containers/#docker-and-starling","text":"Then to connect things back to Starling - The purpose of Starling is to allow you to quickly and easily install and run a UAV simulation within a simulated environment, so that you can test your developed controllers against a semi-realistic scenario, to then test in the real world Therefore Starling is a set of pre-built programs/executables, some of which are pre-configured for the following: Running a Physics Simulation with Visualisation Running the Drone autopilot control software locally (a.k.a Software In The Loop or SITL) Running the interface between Mavlink and other protocols such as the Robot Operating System (ROS) And many others... These pre-built containers are all available in the StarlingUAS repository on github and on Docker Hub.","title":"Docker and Starling"},{"location":"advanced/containers/#packaging-your-controller","text":"","title":"Packaging your controller"},{"location":"advanced/containers/#anatomy-of-a-docker-container","text":"From the user's perspective, a Docker image / container is simply the operating system and essentials - such as installationas, application code, and dependencies. In Starling we create Docker images by using a Dockerfile - a plain text file that provides the specifications for creating a Docker image. See this post for more details In Starling, a controller Docker container is based on the following image template uobflightlabstarling/starling-controller-base:latest It is based on the Ubuntu 20.04 distribution (focal) It has ROS2 FOXY installed in it It has mavros_msgs and a number of other related packages already installed There exists a folder in the root directory /ros_ws which will contain all user space code. This is the ROS2 workspace. Your application source goes into /ros_ws/src .","title":"Anatomy of a Docker Container"},{"location":"advanced/containers/#writing-a-dockerfile","text":"The Dockerfile which specifies your controller is at fenswood_drone_controller/Dockerfile and should look something like the following: 1. FROM uobflightlabstarling/starling-controller-base:latest 2. 3. RUN apt update 4. RUN apt-get install -y ros-foxy-vision-opencv python3-pip 5. RUN pip3 install opencv-python 6. 7. COPY . /ros_ws/src/fenswood_drone_controller 8. 9. RUN . /ros_ws/install/setup.sh \\ && colcon build 10. 11. CMD [ \"ros2\", \"launch\", \"fenswood_drone_controller\", \"controller.launch.xml\" ] When you build a Dockerfile, Docker reads and executes the commands specified line by line. This is similar to when you have a blank linux distribution and start typing instructions to install libraries and applications. Breaking it down line by line: 1. FROM uobflightlabstarling/starling-controller-base:latest This line (the FROM ) tells the builder the Docker image which we should build upon or augment. In this case we are building your application on top of the controller base image. 3. RUN apt update 4. RUN apt-get install -y ros-foxy-vision-opencv python3-pip 5. RUN pip3 install opencv-python Here we are installing the key libraries using apt-get and pip3 , the package managers for ubuntu and python respectively. These libraries are not included in the base image, so we need to add them before your application can run. If you find you need any other dependencies, you will need to install them here. The RUN command tells Docker to simply run the given command inside the container. Simply installing the dependencies on your local machine will do nothing inside the container. 7. COPY . /ros_ws/src/fenswood_drone_controller This COPY command then takes everything locally in the same directory as the Dockerfile (specified using dot . ) and copies it into the container at the path given. This is a normal way of getting files from your local system into the container. Note: Copy will literally copy the state of all of your files at the time of building. Any new changes to your files will not be reflected in the container until your build again. However, there are ways to allow you to do live editing inside the container - see bind mounts - we will need these if you want to get data out. 9. RUN . /ros_ws/install/setup.sh \\ && colcon build This line then compiles your ros nodes. The first command . /ros_ws/install/setup.sh sources ROS2. That means it makes the ROS2 command line commands available for the terminal to use. The second command colcon build . Then builds all of the ros nodes it can find in the src directory. This is the step which builds your container. Note: All RUN commands are run inside the /ros_ws folder. This was specified in the parent image. So colcon build is run inside /ros_ws and therefore looks for ros packages inside /ros_ws/src 11. CMD [ \"ros2\", \"launch\", \"fenswood_drone_controller\", \"controller.launch.xml\" ] Finally, the CMD specifies the command that the Docker image will run when run. Here, by default, the docker contaienr will launch the controller.launch.xml launch file from within fenswood_drone_controller Note: This command is run inside the container using the bash shell. There is a hidden file called /ros_entrypoint.sh which is sourced just before running the command. This entrypoint file sources ros and the /ros_ws workspace so bash knows about your local ros nodes. Note: this CMD can and often is over-ridden. See any of the docker-compose files where we run one of the other controllers.","title":"Writing a Dockerfile"},{"location":"advanced/containers/#building-a-docker-container","text":"Now we have the Dockerfile, the only thing left to do is build it. There are 2 ways: Using the Docker command line tool from the root of this repository. This will create a new docker image called my_application which you can then run. docker build -t my_application fenswood_drone_controller docker run my_application Using Docker-Compose, which is how we've been doing it for the majority of this tutorial. In the docker-compose.yml we specify the relative path to the Dockerfile and docker-compose will build the application for us. controller: build: ../fenswood_drone_controller Note: There is a 3rd method which uses docker buildx which you might see in some of the other Starling projects. This is needed in order to build containers for other computer architectures - such as for the raspberry pi which runs on an Arm64 chip (aka cross-platform). We may cover this at a later date. Note: The build process uses caching to speed up. The Dockerfile commands are run in order so if an earlier command has not changed, or it detects no changes, it will only rebuild the new stuff.","title":"Building a Docker container"},{"location":"advanced/containers/#exercises","text":"Add a new dependency into your code (e.g. use the scipy library for something small). Try and add it to your Dockerfile and rebuild. Change the CMD line to run a different controller launch file by default. Back to tutorial contents","title":"Exercises"},{"location":"advanced/local_testing/","text":"Local Testing and Development workflows \u00b6 Local Testing and Development workflows More efficent local development and testing Splitting the simulator and the controller Sidecar in practice Makefiles Exercises Back to tutorial contents More efficent local development and testing \u00b6 Splitting the simulator and the controller \u00b6 So far, you have been running the controller using docker-compose with the --build command which both builds your controller and starts up the entire simulator stack. You may start to notice that this can sometimes take really long - in particular the simulator start up can sometimes be annoyingly inconsistant. Therefore Starling introduces a new paradigm which allows you to attach and detach a sidecar application container to your simulation. (This example is from PX4, but the same applies for Ardupilot!) Essentially we start the simulator stack on its own in one termianl. Then with the instructions from the previous tutorial we can create a standalone application container which we can build, restart and test without needing to restart the entire simulator! Note: If the drone crashes or the autopilot becomes unresponsive, you will still need to restart your simulator. However this method should reduce the number of simulator restarts required. Sidecar in practice \u00b6 To run the simulator only, you can use the docker-compose file in 8_containers . Therefore in one terminal, run the following. docker-compose -f 8_containers/docker-compose.yml up Then start a new terminal . Note that when you run docker-compose, it will start a new mini Docker network in which it communicates over. We first need to find the name of this network so that we when we run our application, ROS2 can find the simulator. $ docker network ls NETWORK ID NAME DRIVER SCOPE 04468b7ccad2 1_old_school_default bridge local 1282aac186af 7_multi_part_default bridge local 472239bc901c 8_containers_default bridge local <--- 546d35750dc0 bridge bridge local 681c73eec26a deployment_default bridge local ... Running the above we identify that 8_containers_default is the name of the network. Note: In general the network name is the <parent directory of docker-compose file>_default . We then build and run our container, remembering to specify our network. docker build -t my_application:latest fenswood_drone_controller docker run -it --rm --net=8_containers_default my_application:latest This will hopefully start your application, and it will hopefully connect to the simulator. Then if you make any changes, you just need to rebuild and rerun your application and it will automatically reconnect via ROS. Makefiles \u00b6 The final element to be introduced is the Makefile . A Makefile is a simple tool which we like using to streamline the number of commands we have to manually enter. An example makefile can be found in 8_containers/Makefile MAKEFILE_DIR:=$(shell dirname $(realpath $(firstword $(MAKEFILE_LIST)))) DOCKERFILE:=$(MAKEFILE_DIR)/../fenswood_drone_controller IMAGE_NAME?=fenswood_drone_controller NETWORK?=8_containers_default ENV?= RUN_ARGS?= all: build help: @echo \"all - run build\" @echo \"build - build the dockerfile for this project\" @echo \"run - builds and runs the dockerfile for this project\" @echo \"run_bash - builds and runs the dockerfile putting you into a bash shell\" @echo \"help - show this help screen\" build: docker build -t $(IMAGE_NAME) $(DOCKERFILE) run: build docker run -it --rm --net=$(NETWORK) $(ENV) -e USE_SIMULATED_TIME=true $(RUN_ARGS) $(IMAGE_NAME) run_bash: build docker run -it --rm --net=$(NETWORK) $(ENV) -e USE_SIMULATED_TIME=true $(RUN_ARGS) $(IMAGE_NAME) bash .PHONY: all help build run run_bash Then breaking this down, this Makefile defines 5 commands which can be run: all , help , build , run and run_bash . These can each be run from inside the 8_containers directory using the make <command> command. For example make # By default just make will run the first command in the file make run # This will run the `run` command MAKEFILE_DIR:=$(shell dirname $(realpath $(firstword $(MAKEFILE_LIST)))) DOCKERFILE:=$(MAKEFILE_DIR)/../fenswood_drone_controller IMAGE_NAME?=fenswood_drone_controller NETWORK?=8_containers_default ENV?= RUN_ARGS?= These lines define useful variables which are used within the Makefile. These can be changed to whatever suits. The := equality defines variables which cannot be changed. The ?= defines variables which can be changed at run time. For example you could change network at runtime by running: make run NETWORK=someothernetwork_default run: build docker run -it --rm --net=$(NETWORK) $(ENV) -e USE_SIMULATED_TIME=true $(RUN_ARGS) $(IMAGE_NAME) Singling out the run command, there are a number of features. First after the colon, we specify the build command. This represents a dependency of run on build . Therefore the build command is always run before the run command. The command is then defined on the second line. This can literally be any bash command. Here we specify the running of the image we build. See how it uses all of the variables we defined at the top of the file. .PHONY: all help build run run_bash This final line just tells make that theses are valid makefile commands, and not folders or anything else of the same name. Then in the context of Starling, instead of manually running the docker build and docker run commands, I like the simplicity of just running make run to rebuild and run my application container. Exercises \u00b6 Try and run your application in sidecar mode. Make a change to your source and try and re-run your controller without restarting the simulator. Write a simple Makefile for you to use Add an extra command to the makefile called simulator which runs the command needed to start the simulation stack Back to tutorial contents","title":"4. Local Development and Testing"},{"location":"advanced/local_testing/#local-testing-and-development-workflows","text":"Local Testing and Development workflows More efficent local development and testing Splitting the simulator and the controller Sidecar in practice Makefiles Exercises Back to tutorial contents","title":"Local Testing and Development workflows"},{"location":"advanced/local_testing/#more-efficent-local-development-and-testing","text":"","title":"More efficent local development and testing"},{"location":"advanced/local_testing/#splitting-the-simulator-and-the-controller","text":"So far, you have been running the controller using docker-compose with the --build command which both builds your controller and starts up the entire simulator stack. You may start to notice that this can sometimes take really long - in particular the simulator start up can sometimes be annoyingly inconsistant. Therefore Starling introduces a new paradigm which allows you to attach and detach a sidecar application container to your simulation. (This example is from PX4, but the same applies for Ardupilot!) Essentially we start the simulator stack on its own in one termianl. Then with the instructions from the previous tutorial we can create a standalone application container which we can build, restart and test without needing to restart the entire simulator! Note: If the drone crashes or the autopilot becomes unresponsive, you will still need to restart your simulator. However this method should reduce the number of simulator restarts required.","title":"Splitting the simulator and the controller"},{"location":"advanced/local_testing/#sidecar-in-practice","text":"To run the simulator only, you can use the docker-compose file in 8_containers . Therefore in one terminal, run the following. docker-compose -f 8_containers/docker-compose.yml up Then start a new terminal . Note that when you run docker-compose, it will start a new mini Docker network in which it communicates over. We first need to find the name of this network so that we when we run our application, ROS2 can find the simulator. $ docker network ls NETWORK ID NAME DRIVER SCOPE 04468b7ccad2 1_old_school_default bridge local 1282aac186af 7_multi_part_default bridge local 472239bc901c 8_containers_default bridge local <--- 546d35750dc0 bridge bridge local 681c73eec26a deployment_default bridge local ... Running the above we identify that 8_containers_default is the name of the network. Note: In general the network name is the <parent directory of docker-compose file>_default . We then build and run our container, remembering to specify our network. docker build -t my_application:latest fenswood_drone_controller docker run -it --rm --net=8_containers_default my_application:latest This will hopefully start your application, and it will hopefully connect to the simulator. Then if you make any changes, you just need to rebuild and rerun your application and it will automatically reconnect via ROS.","title":"Sidecar in practice"},{"location":"advanced/local_testing/#makefiles","text":"The final element to be introduced is the Makefile . A Makefile is a simple tool which we like using to streamline the number of commands we have to manually enter. An example makefile can be found in 8_containers/Makefile MAKEFILE_DIR:=$(shell dirname $(realpath $(firstword $(MAKEFILE_LIST)))) DOCKERFILE:=$(MAKEFILE_DIR)/../fenswood_drone_controller IMAGE_NAME?=fenswood_drone_controller NETWORK?=8_containers_default ENV?= RUN_ARGS?= all: build help: @echo \"all - run build\" @echo \"build - build the dockerfile for this project\" @echo \"run - builds and runs the dockerfile for this project\" @echo \"run_bash - builds and runs the dockerfile putting you into a bash shell\" @echo \"help - show this help screen\" build: docker build -t $(IMAGE_NAME) $(DOCKERFILE) run: build docker run -it --rm --net=$(NETWORK) $(ENV) -e USE_SIMULATED_TIME=true $(RUN_ARGS) $(IMAGE_NAME) run_bash: build docker run -it --rm --net=$(NETWORK) $(ENV) -e USE_SIMULATED_TIME=true $(RUN_ARGS) $(IMAGE_NAME) bash .PHONY: all help build run run_bash Then breaking this down, this Makefile defines 5 commands which can be run: all , help , build , run and run_bash . These can each be run from inside the 8_containers directory using the make <command> command. For example make # By default just make will run the first command in the file make run # This will run the `run` command MAKEFILE_DIR:=$(shell dirname $(realpath $(firstword $(MAKEFILE_LIST)))) DOCKERFILE:=$(MAKEFILE_DIR)/../fenswood_drone_controller IMAGE_NAME?=fenswood_drone_controller NETWORK?=8_containers_default ENV?= RUN_ARGS?= These lines define useful variables which are used within the Makefile. These can be changed to whatever suits. The := equality defines variables which cannot be changed. The ?= defines variables which can be changed at run time. For example you could change network at runtime by running: make run NETWORK=someothernetwork_default run: build docker run -it --rm --net=$(NETWORK) $(ENV) -e USE_SIMULATED_TIME=true $(RUN_ARGS) $(IMAGE_NAME) Singling out the run command, there are a number of features. First after the colon, we specify the build command. This represents a dependency of run on build . Therefore the build command is always run before the run command. The command is then defined on the second line. This can literally be any bash command. Here we specify the running of the image we build. See how it uses all of the variables we defined at the top of the file. .PHONY: all help build run run_bash This final line just tells make that theses are valid makefile commands, and not folders or anything else of the same name. Then in the context of Starling, instead of manually running the docker build and docker run commands, I like the simplicity of just running make run to rebuild and run my application container.","title":"Makefiles"},{"location":"advanced/local_testing/#exercises","text":"Try and run your application in sidecar mode. Make a change to your source and try and re-run your controller without restarting the simulator. Write a simple Makefile for you to use Add an extra command to the makefile called simulator which runs the command needed to start the simulation stack Back to tutorial contents","title":"Exercises"},{"location":"advanced/ros_package/","text":"Developing a ROS Package \u00b6 Developing a ROS Package ROS2 Packages Inspecting the package \"Where\" is my ROS2 package and package compilation Multi-File Nodes Implementing multi-file nodes Exercises Back to tutorial contents ROS2 Packages \u00b6 In the core tutorial, the focus was on the controller source code within your Python files. In Adding Perception we very briefly touched on launch files, but will did not go into much detail as to what is the rest of a ROS2 package - and this has some knock-on effects when you want to implement new functionality! Inspecting the package \u00b6 Inspecting the fenswood_drone_controller source folder we see a few more folders and files. fenswood_drone_controller - the folder which contains your source code, it is considered a python package and therefore should have an __init__.py file. launch - the folder which contains all of your launch files for various versions of your controller. resource - a Python ROS2 package specific folder which contains the executable your controller gets compiled into. Dockerfile - not a part of a ROS2 package, this is Starling specific, see a later tutorial for more details. package.xml - This is an xml file which ROS2 reads to find details of your package. This includes the packages and libraries that your project depends on. (It is not used here, but there is a tool called rosdep which reads this file and is often used to automatically find dependencies ) setup.cfg - This is an autogenerated file which defines where to install this package. setup.py - The main configuration file for ROS2 Python packages. It defines the name of your ROS2 nodes within this package, as well as specifies which files get copied to the compiled version of the package. \"Where\" is my ROS2 package and package compilation \u00b6 In the previous tutorials, implementing and writing the Python probably felt like previous times you may have used interpreted languages. You make a change, then you run your script and you can see your changes. In fact, as part of Starling, we wanted it to feel like that to make it easier to pick up and use. However, it is actually slightly more complicated when it comes to ROS2 nodes. There is a hidden step in which your ROS2 nodes are compiled , even if you are writing Python where you don't traditionally compile anything! Note: In our Starling system, the compilation auomatically happens when you run docker-compose -f ... up --build . The process of compilation takes your ROS2 package and compresses it into a set of executables which run your program and copies it into a install folder. Whenever the package is run, it then runs from the executables within the build folder. This has some knock on effects: Writing code without compiling it won't actually change the existing executables! If you have static data in folders within the package, such as images or configuration files, your executable might complain that it can't find them when you run it! This is because you haven't told the compiler to also copy your new files. You have to add your new files into the data_files list in setup.py . The syntax is to add a tuple of (\"share/\" + package_name, ['A list of', 'my extra files']) . If you create a new ros node, it will not immediately be available for running or use in a launch file. You have to add your ros node as a new entry_point in setup.py Similarly if you create a new launch file but it doesn't shown up, make sure the file has name *.launch.* and is in the launch folder. See the setup.py file again. Note: As we will see in the container tutorial, all of this is not immediately obvious as its all inside the application container. See Exercises. Multi-File Nodes \u00b6 So far all of the ros-nodes have been implemented using a single control file. In this file you are sending Mavlink commands to the drone, keeping track of the navigation as well as keeping track of the higher level mission all at the same time! As you grow your application, you may start finding the maintenance of a monolithic single file source challenging. Often we want to organise our code by some abstract notion, like functionality or purpose. For instance we want one module which just takes care of sending and receiving commands for the drone, such that if we change the overall mission, we don't accidentally break the drone communication code. One example of a similar concept is given in perception where we create an extra node whose sole job is to monitor the camera inputs. We could have put that into the controller itself rather than having an extra node, and incuring the extra costs that might be involved in creating a new node. An alternative to multi file nodes would be to make use of a new ROS2 feature called composition . We have not explored it in Starling so far, but feel free to give it a go too. Implementing multi-file nodes \u00b6 Fortunately it's almost as simply as normal Python to refactor your source into multiple files. However, there are a number of important differences, let us walk through the core changes showing in the multi_part_controller_mission.py file. The source code in fenswood_drone_controller is registered as a python package . There are a number of effects of this, but the main one being that when you import your sub-file in your main file, you have to add a . : from .multi_part_controller_drone_only import DroneController ^ If your sub-file requires use of ROS2 node functionality (e.g. creating clients, parameters etc), you will need to pass a reference to the ROS2 node into the sub class. This is a little more challenging to explain - as this source code we're implementing here still represents the same single ROS2 node, all of the publishers, subscribers and other ROS2 features have to be created by the same node instance - no matter in which source file/ sub class we use. Therefore if we wish to create - say - a subscriber to mavros/state in the drone controller subclass, the DroneController will need access to the node to create the subscriber. The only way to do this is to pass in the rosnode in DroneController 's constructor: class DroneController(): def __init__(self, node): self.node = node # store the rosnode object ... self.node.create_subscription(State, '/vehicle_1/mavros/state', self.state_callback, 10) \"Wait\", I hear you ask, aren't functions like create_subscription a part of the node itself, how do I pass the node to DroneController ... in fact where even is \"the node\"? Rewind to when we introduced objects and classes we created the FenswoodDroneController as a child of the ROS Node class. This means that FenswoodDroneController has all the properties of the Node and therefore is itself the node! Then how does a class refer to itself - through the self keyword of course! In Python the self is actually a reference to itself. So you can pass self to functions if you want the function to have access or change the state of self , just like passing any other variable to a function. Therefore in order to make multiple-source files work, we create a new controller property which represents the drone using the DroneController created previously. We then pass self into the drone to represent the ros node. This passes the node reference in so that DroneController then has access to node functions such as create_subscription ! from .multi_part_controller_drone_only import DroneController class FenswoodDroneController(Node): def __init__(self): super().__init__('controller') # Create object representing drone self.drone = DroneController(self) This can then be repeated each time you wish to refactor into multiple source files. This may feel weird and self-referential, but it works! Note: Watch that the names of node parameters dont clash over the files, and that you don't create multiple publishers, subscribers and services that point to the same topic. Since these are all part of the same node, the node only likes unique things. If you find yourself needing to create multiple of the same subscriber, for example, you may need to reconsider whether your refactoring. You can run this example using the following. Note that this is not yet tested so feel free to submit a Pull Request if it doesn't fully work yet! docker-compose -f 7_multi_part/docker-compose.yml up --build Exercises \u00b6 Let us inspect your ROS2 package and what it's like after compilation. First run docker-compose.yml up in one terminal. Open up another terminal and use the docker ps to find the container id of your application container and docker exec -it <container id> bash to go inside the container. See this tutorial for more details. Once inside the container, you should be in the /ros_ws directory. Running ls -al you should see a number of directories. Your source code should be in src . Have a look in the other folders. In the ROS2 workspace root (i.e. /ros_ws ) you can recompile yourself manually. First enable ROS2 by running source /opt/ros/foxy/setup.bash , then run colcon build . While there you can also try and launch some of the other controllers you have been working on! Lets say you want to add a new folder config as your code needs to read a configuration file named fenswood.yaml (It can just contain a single field). Add the reading of this configuration file into your source code with some logging. Modify the setup.py file so that your application can read your configuration when run. Try and pull out the drone related functionality into its own source file, while still remaining part of the same rosnode.","title":"2. Developing a ROS package"},{"location":"advanced/ros_package/#developing-a-ros-package","text":"Developing a ROS Package ROS2 Packages Inspecting the package \"Where\" is my ROS2 package and package compilation Multi-File Nodes Implementing multi-file nodes Exercises Back to tutorial contents","title":"Developing a ROS Package"},{"location":"advanced/ros_package/#ros2-packages","text":"In the core tutorial, the focus was on the controller source code within your Python files. In Adding Perception we very briefly touched on launch files, but will did not go into much detail as to what is the rest of a ROS2 package - and this has some knock-on effects when you want to implement new functionality!","title":"ROS2 Packages"},{"location":"advanced/ros_package/#inspecting-the-package","text":"Inspecting the fenswood_drone_controller source folder we see a few more folders and files. fenswood_drone_controller - the folder which contains your source code, it is considered a python package and therefore should have an __init__.py file. launch - the folder which contains all of your launch files for various versions of your controller. resource - a Python ROS2 package specific folder which contains the executable your controller gets compiled into. Dockerfile - not a part of a ROS2 package, this is Starling specific, see a later tutorial for more details. package.xml - This is an xml file which ROS2 reads to find details of your package. This includes the packages and libraries that your project depends on. (It is not used here, but there is a tool called rosdep which reads this file and is often used to automatically find dependencies ) setup.cfg - This is an autogenerated file which defines where to install this package. setup.py - The main configuration file for ROS2 Python packages. It defines the name of your ROS2 nodes within this package, as well as specifies which files get copied to the compiled version of the package.","title":"Inspecting the package"},{"location":"advanced/ros_package/#where-is-my-ros2-package-and-package-compilation","text":"In the previous tutorials, implementing and writing the Python probably felt like previous times you may have used interpreted languages. You make a change, then you run your script and you can see your changes. In fact, as part of Starling, we wanted it to feel like that to make it easier to pick up and use. However, it is actually slightly more complicated when it comes to ROS2 nodes. There is a hidden step in which your ROS2 nodes are compiled , even if you are writing Python where you don't traditionally compile anything! Note: In our Starling system, the compilation auomatically happens when you run docker-compose -f ... up --build . The process of compilation takes your ROS2 package and compresses it into a set of executables which run your program and copies it into a install folder. Whenever the package is run, it then runs from the executables within the build folder. This has some knock on effects: Writing code without compiling it won't actually change the existing executables! If you have static data in folders within the package, such as images or configuration files, your executable might complain that it can't find them when you run it! This is because you haven't told the compiler to also copy your new files. You have to add your new files into the data_files list in setup.py . The syntax is to add a tuple of (\"share/\" + package_name, ['A list of', 'my extra files']) . If you create a new ros node, it will not immediately be available for running or use in a launch file. You have to add your ros node as a new entry_point in setup.py Similarly if you create a new launch file but it doesn't shown up, make sure the file has name *.launch.* and is in the launch folder. See the setup.py file again. Note: As we will see in the container tutorial, all of this is not immediately obvious as its all inside the application container. See Exercises.","title":"\"Where\" is my ROS2 package and package compilation"},{"location":"advanced/ros_package/#multi-file-nodes","text":"So far all of the ros-nodes have been implemented using a single control file. In this file you are sending Mavlink commands to the drone, keeping track of the navigation as well as keeping track of the higher level mission all at the same time! As you grow your application, you may start finding the maintenance of a monolithic single file source challenging. Often we want to organise our code by some abstract notion, like functionality or purpose. For instance we want one module which just takes care of sending and receiving commands for the drone, such that if we change the overall mission, we don't accidentally break the drone communication code. One example of a similar concept is given in perception where we create an extra node whose sole job is to monitor the camera inputs. We could have put that into the controller itself rather than having an extra node, and incuring the extra costs that might be involved in creating a new node. An alternative to multi file nodes would be to make use of a new ROS2 feature called composition . We have not explored it in Starling so far, but feel free to give it a go too.","title":"Multi-File Nodes"},{"location":"advanced/ros_package/#implementing-multi-file-nodes","text":"Fortunately it's almost as simply as normal Python to refactor your source into multiple files. However, there are a number of important differences, let us walk through the core changes showing in the multi_part_controller_mission.py file. The source code in fenswood_drone_controller is registered as a python package . There are a number of effects of this, but the main one being that when you import your sub-file in your main file, you have to add a . : from .multi_part_controller_drone_only import DroneController ^ If your sub-file requires use of ROS2 node functionality (e.g. creating clients, parameters etc), you will need to pass a reference to the ROS2 node into the sub class. This is a little more challenging to explain - as this source code we're implementing here still represents the same single ROS2 node, all of the publishers, subscribers and other ROS2 features have to be created by the same node instance - no matter in which source file/ sub class we use. Therefore if we wish to create - say - a subscriber to mavros/state in the drone controller subclass, the DroneController will need access to the node to create the subscriber. The only way to do this is to pass in the rosnode in DroneController 's constructor: class DroneController(): def __init__(self, node): self.node = node # store the rosnode object ... self.node.create_subscription(State, '/vehicle_1/mavros/state', self.state_callback, 10) \"Wait\", I hear you ask, aren't functions like create_subscription a part of the node itself, how do I pass the node to DroneController ... in fact where even is \"the node\"? Rewind to when we introduced objects and classes we created the FenswoodDroneController as a child of the ROS Node class. This means that FenswoodDroneController has all the properties of the Node and therefore is itself the node! Then how does a class refer to itself - through the self keyword of course! In Python the self is actually a reference to itself. So you can pass self to functions if you want the function to have access or change the state of self , just like passing any other variable to a function. Therefore in order to make multiple-source files work, we create a new controller property which represents the drone using the DroneController created previously. We then pass self into the drone to represent the ros node. This passes the node reference in so that DroneController then has access to node functions such as create_subscription ! from .multi_part_controller_drone_only import DroneController class FenswoodDroneController(Node): def __init__(self): super().__init__('controller') # Create object representing drone self.drone = DroneController(self) This can then be repeated each time you wish to refactor into multiple source files. This may feel weird and self-referential, but it works! Note: Watch that the names of node parameters dont clash over the files, and that you don't create multiple publishers, subscribers and services that point to the same topic. Since these are all part of the same node, the node only likes unique things. If you find yourself needing to create multiple of the same subscriber, for example, you may need to reconsider whether your refactoring. You can run this example using the following. Note that this is not yet tested so feel free to submit a Pull Request if it doesn't fully work yet! docker-compose -f 7_multi_part/docker-compose.yml up --build","title":"Implementing multi-file nodes"},{"location":"advanced/ros_package/#exercises","text":"Let us inspect your ROS2 package and what it's like after compilation. First run docker-compose.yml up in one terminal. Open up another terminal and use the docker ps to find the container id of your application container and docker exec -it <container id> bash to go inside the container. See this tutorial for more details. Once inside the container, you should be in the /ros_ws directory. Running ls -al you should see a number of directories. Your source code should be in src . Have a look in the other folders. In the ROS2 workspace root (i.e. /ros_ws ) you can recompile yourself manually. First enable ROS2 by running source /opt/ros/foxy/setup.bash , then run colcon build . While there you can also try and launch some of the other controllers you have been working on! Lets say you want to add a new folder config as your code needs to read a configuration file named fenswood.yaml (It can just contain a single field). Add the reading of this configuration file into your source code with some logging. Modify the setup.py file so that your application can read your configuration when run. Try and pull out the drone related functionality into its own source file, while still remaining part of the same rosnode.","title":"Exercises"},{"location":"advanced/starling/","text":"The Starling framework \u00b6 The Starling framework Introduction What is Starling ...v2 Docker Compose Starling Application Containers What actually is Starling Exercises Back to tutorial contents Introduction \u00b6 This tutorial template is built on the Starling framework which combines open-source components to provide a realistic, cross-platform simulation for drone flight. So far from the standard tutorial, you should be aware of the following technologies. Gazebo , a physical and visual simulation package Ardupilot , a free autopilot software with MAVLINK interfacing and simulation capability ROS , a popular software framework for robot interfacing, plus the MAVROS package for connecting MAVLINK drones to ROS. OpenCV , an image processing library with Python support Docker , a system for packaging and deploying Surely there's a simpler way? Almost certainly, but you wouldn't learn so much. These are the standard tools of the robotics trade, and while it'll take you a while to learn them, the skills you get will go far beyond this project. This way also means we can do more with Starling, like migrate controllers from simulation to actual flight. In this tutorial we will providing a bit more detail into what Starling actually is and providing a brief overview of some of the components that comprise Starling, and how they work together to provide you a platform to build your applications upon. What is Starling ...v2 \u00b6 I'm sure when we mention Starling, it's still a nebulous thing thats quite hard to define right now. When we previously introduced Starling, we simply said that it's a thing we developed which allows you to quickly and easily install and run a UAV simulation within a simulated environment to allow you to develop and test your contorllers for this project. Now you hopefully have a bit more experience in using the stuff that Starling provides, you might be wondering whether that's actually the whole story - and you'd be right! Let's first recap the parts of Starling you will have touched. Docker Compose \u00b6 Multiple times in this tutorial you should have run the docker-compose up --build command that starts the simulation. If you have a look inside one of these compose files, you'll see something like the following yaml format file: services: controller: build: ../fenswood_drone_controller simhost: image: uobflightlabstarling/starling-sim-iris-ap-fenswood:latest environment: - AP_SITL_HOST=sitl ports: - \"8080:8080\" sitl: image: uobflightlabstarling/starling-sim-ardupilot-copter:v0.0.8 environment: - ... mavros: image: uobflightlabstarling/starling-mavros:v0.1.0 command: ros2 launch launch/mavros_bridge.launch.xml environment: - ... ports: - \"5761:5761\" rosbridge-suite: image: uobflightlabstarling/rosbridge-suite:v0.1.0 ports: - \"9090:9090\" Firstly we note that this configuration uses a file format known as yaml, as opposed to json or xml. It uses tabs/indentation to denote groupings of key-value pairs or lists. The configuration specifies a set of services which we have named controller , simhost , sitl , mavros and rosbridge-suite . Each service defines an application container to be run all at the same time, giving us the 'recipe' for what containers to run to generate this application. Docker-compose launches all of these containers together, a bit like starting a set of virtual computers which are all networked together. Most of the application containers, such as simhost , sitl , mavros and rosbridge-suite are defined by their image field which specifies the particular container to download and run. The other fields such as environment and port are used to speficy environment variables and ports respectively for the image. The controller is a special container which is built directly by docker-compose. The build field specifies a path to the Dockerfile which containers the instructions for building the application. In this case, the application is your fenswood drone control ros nodes which you have been modifying in the earlier tutorials. Specifying --build on the end of docker-compose requests docker compose to re-build this controller application container. Starling Application Containers \u00b6 Apart from the controller which contains your own application code, all of the other application containers are provided by Starling . simhost : uobflightlabstarling/starling-sim-iris-ap-fenswood:latest Gazebo , the physics simulator. Given commands from the autopilot, it simulates how the drone moves. Gazebo also provides graphics, simulating the drone cemra feed and sending it to ROS, and providing a representation of the world for us to spy on via the browser interface on localhost:8080 . In particular this application container is from FenswoodScenario which includes the Fenswood map, along with the simulation elements needed to represent this task. sitl : uobflightlabstarling/starling-sim-ardupilot-copter:latest Ardupilot , a free autopilot software with MAVLINK interfacing and simulation capability. This application container automatically finds and connects to the simulator, spawns a model and connects the software autopilot running Ardupilot to the now spawned gazebo model. mavros : uobflightlabstarling/starling-mavros:latest MAVROS package for connecting MAVLINK drones to ROS. This application container automatically starts and connects the SITL as if it was a real drone. It then provides a ROS2 Foxy api for user applications to interact with the simulated drone. It also serves to forward MAVLINK to a ground station or a PyMavlink application. rosbridge-suite : uobflightlabstarling/rosbridge-suite:latest Rosbridge-suite package for translating ROS2 packets into JSON for communication with web base ROS2 (roslibjs) This application container forwards ROS2 comms over to web based applications such as Foxglove Studio or your own web based applications such as the Starling example ui . Each of these application containers are built using Docker and uploaded onto Docker Hub publically so they are available to all to download and use. Starling uses Docker to package up the simulation framework and other applications for use on different computers. I found the Duckietown introduction really good for getting a feel for Docker. We'll go into more detail in what Docker actually is in the next tutorial. You may have also noticed, readin through the above, we mention \"automatically\" a lot in the function of some of these containers. Usefully for you, many of the above containers have extra configuration and startup steps above and beyond the individual base applications to ensure that the usage and interconnectivity of all the different parts of the simulations are smooth and hassle free! Note It's useful to keep the idea that each container has a custom startup sequence. For more complex tasks and modifications, you may be able to leverage this paradigm. It is also an avenue to consider when bug hunting integration testing your application. What actually is Starling \u00b6 Even for the extended purpose of this advanced tutorial, the above should be sufficient background knowledge. However for completeness, here we finally describe what exactly Starling is. Starling is an end to end, modular, containerised UAV infrastucture designed to facilitate the local development, testing and deployment of Single and Multi-UAV systems from simulation to the Bristol Robotics Lab Flight Arena and Fenswwod farm. It will hopefully allow for a more approachable development workflow to enable more researchers to fly UAVs in a safe, reproducable and controllable manner. This diagram describes the full intended architecture of the usage of Starling in a multi-vehicle use case. It includes another deployment layer above which you will not need to know about for the purpose of this project. For those who really want to read further, check out this further tutorial Just keep in mind that Starling has been developed for many uses, of which this project is but one. While complex, the design allows for flexibility for use in many places! Back to tutorial contents Exercises \u00b6 Have a browser of the Starling projects available on github ( StarlingUAS ), as well as the containers available on the uobflightlabstarling organisation on Docker Hub . (You may need to create an account - this may come in handy during this project). Change the port number for simhost in one of your docker-compose files and run it. Try and navigate to it in the browser. There exists an example web user interface as the image uobflightlabstarling/starling-ui-example:latest . Add a new entry in your docker-compose file so that you can also run this example ui as part of your simulation. Note that you will need to enable ports 9090 and 3000 before you can access the UI from your browser. Back to tutorial contents","title":"1. Brief Starling Introduction"},{"location":"advanced/starling/#the-starling-framework","text":"The Starling framework Introduction What is Starling ...v2 Docker Compose Starling Application Containers What actually is Starling Exercises Back to tutorial contents","title":"The Starling framework"},{"location":"advanced/starling/#introduction","text":"This tutorial template is built on the Starling framework which combines open-source components to provide a realistic, cross-platform simulation for drone flight. So far from the standard tutorial, you should be aware of the following technologies. Gazebo , a physical and visual simulation package Ardupilot , a free autopilot software with MAVLINK interfacing and simulation capability ROS , a popular software framework for robot interfacing, plus the MAVROS package for connecting MAVLINK drones to ROS. OpenCV , an image processing library with Python support Docker , a system for packaging and deploying Surely there's a simpler way? Almost certainly, but you wouldn't learn so much. These are the standard tools of the robotics trade, and while it'll take you a while to learn them, the skills you get will go far beyond this project. This way also means we can do more with Starling, like migrate controllers from simulation to actual flight. In this tutorial we will providing a bit more detail into what Starling actually is and providing a brief overview of some of the components that comprise Starling, and how they work together to provide you a platform to build your applications upon.","title":"Introduction"},{"location":"advanced/starling/#what-is-starling-v2","text":"I'm sure when we mention Starling, it's still a nebulous thing thats quite hard to define right now. When we previously introduced Starling, we simply said that it's a thing we developed which allows you to quickly and easily install and run a UAV simulation within a simulated environment to allow you to develop and test your contorllers for this project. Now you hopefully have a bit more experience in using the stuff that Starling provides, you might be wondering whether that's actually the whole story - and you'd be right! Let's first recap the parts of Starling you will have touched.","title":"What is Starling ...v2"},{"location":"advanced/starling/#docker-compose","text":"Multiple times in this tutorial you should have run the docker-compose up --build command that starts the simulation. If you have a look inside one of these compose files, you'll see something like the following yaml format file: services: controller: build: ../fenswood_drone_controller simhost: image: uobflightlabstarling/starling-sim-iris-ap-fenswood:latest environment: - AP_SITL_HOST=sitl ports: - \"8080:8080\" sitl: image: uobflightlabstarling/starling-sim-ardupilot-copter:v0.0.8 environment: - ... mavros: image: uobflightlabstarling/starling-mavros:v0.1.0 command: ros2 launch launch/mavros_bridge.launch.xml environment: - ... ports: - \"5761:5761\" rosbridge-suite: image: uobflightlabstarling/rosbridge-suite:v0.1.0 ports: - \"9090:9090\" Firstly we note that this configuration uses a file format known as yaml, as opposed to json or xml. It uses tabs/indentation to denote groupings of key-value pairs or lists. The configuration specifies a set of services which we have named controller , simhost , sitl , mavros and rosbridge-suite . Each service defines an application container to be run all at the same time, giving us the 'recipe' for what containers to run to generate this application. Docker-compose launches all of these containers together, a bit like starting a set of virtual computers which are all networked together. Most of the application containers, such as simhost , sitl , mavros and rosbridge-suite are defined by their image field which specifies the particular container to download and run. The other fields such as environment and port are used to speficy environment variables and ports respectively for the image. The controller is a special container which is built directly by docker-compose. The build field specifies a path to the Dockerfile which containers the instructions for building the application. In this case, the application is your fenswood drone control ros nodes which you have been modifying in the earlier tutorials. Specifying --build on the end of docker-compose requests docker compose to re-build this controller application container.","title":"Docker Compose"},{"location":"advanced/starling/#starling-application-containers","text":"Apart from the controller which contains your own application code, all of the other application containers are provided by Starling . simhost : uobflightlabstarling/starling-sim-iris-ap-fenswood:latest Gazebo , the physics simulator. Given commands from the autopilot, it simulates how the drone moves. Gazebo also provides graphics, simulating the drone cemra feed and sending it to ROS, and providing a representation of the world for us to spy on via the browser interface on localhost:8080 . In particular this application container is from FenswoodScenario which includes the Fenswood map, along with the simulation elements needed to represent this task. sitl : uobflightlabstarling/starling-sim-ardupilot-copter:latest Ardupilot , a free autopilot software with MAVLINK interfacing and simulation capability. This application container automatically finds and connects to the simulator, spawns a model and connects the software autopilot running Ardupilot to the now spawned gazebo model. mavros : uobflightlabstarling/starling-mavros:latest MAVROS package for connecting MAVLINK drones to ROS. This application container automatically starts and connects the SITL as if it was a real drone. It then provides a ROS2 Foxy api for user applications to interact with the simulated drone. It also serves to forward MAVLINK to a ground station or a PyMavlink application. rosbridge-suite : uobflightlabstarling/rosbridge-suite:latest Rosbridge-suite package for translating ROS2 packets into JSON for communication with web base ROS2 (roslibjs) This application container forwards ROS2 comms over to web based applications such as Foxglove Studio or your own web based applications such as the Starling example ui . Each of these application containers are built using Docker and uploaded onto Docker Hub publically so they are available to all to download and use. Starling uses Docker to package up the simulation framework and other applications for use on different computers. I found the Duckietown introduction really good for getting a feel for Docker. We'll go into more detail in what Docker actually is in the next tutorial. You may have also noticed, readin through the above, we mention \"automatically\" a lot in the function of some of these containers. Usefully for you, many of the above containers have extra configuration and startup steps above and beyond the individual base applications to ensure that the usage and interconnectivity of all the different parts of the simulations are smooth and hassle free! Note It's useful to keep the idea that each container has a custom startup sequence. For more complex tasks and modifications, you may be able to leverage this paradigm. It is also an avenue to consider when bug hunting integration testing your application.","title":"Starling Application Containers"},{"location":"advanced/starling/#what-actually-is-starling","text":"Even for the extended purpose of this advanced tutorial, the above should be sufficient background knowledge. However for completeness, here we finally describe what exactly Starling is. Starling is an end to end, modular, containerised UAV infrastucture designed to facilitate the local development, testing and deployment of Single and Multi-UAV systems from simulation to the Bristol Robotics Lab Flight Arena and Fenswwod farm. It will hopefully allow for a more approachable development workflow to enable more researchers to fly UAVs in a safe, reproducable and controllable manner. This diagram describes the full intended architecture of the usage of Starling in a multi-vehicle use case. It includes another deployment layer above which you will not need to know about for the purpose of this project. For those who really want to read further, check out this further tutorial Just keep in mind that Starling has been developed for many uses, of which this project is but one. While complex, the design allows for flexibility for use in many places! Back to tutorial contents","title":"What actually is Starling"},{"location":"advanced/starling/#exercises","text":"Have a browser of the Starling projects available on github ( StarlingUAS ), as well as the containers available on the uobflightlabstarling organisation on Docker Hub . (You may need to create an account - this may come in handy during this project). Change the port number for simhost in one of your docker-compose files and run it. Try and navigate to it in the browser. There exists an example web user interface as the image uobflightlabstarling/starling-ui-example:latest . Add a new entry in your docker-compose file so that you can also run this example ui as part of your simulation. Note that you will need to enable ports 9090 and 3000 before you can access the UI from your browser. Back to tutorial contents","title":"Exercises"},{"location":"tutorial/conclusion/","text":"Conclusion and Next Steps \u00b6 Congratulations! You have finished the fenswood volcano tutorial on writing your own MAVLINK and ROS2 compatible controller. Hopefully now you have learnt and understood how Mavlink is used to communicate to the drone and how to use ROS to control the drone with Mavlink. You should have also seen a number of different ways of organising your code in a more modular fashion to allow greater flexibitiliy and reliability in your implementations. Finally we showed how you might add Perception through the use of OpenCV in order to autonomously control your drone if you so wish! At this point, you should have enough knowledge to be able to create a controller which can solve the task in a simple way. However, you have probably noticed that there's probably a lot more going on under the surface. So for those wanting to do some more complex tasks, you may be interested in learning a bit more about the underlying simulation. For you, I would recommend carrying on to the Advanced Tutorial. The advanced tutorial will more formally introduce you to the Starling simulation system that you have been using and how your ROS controller fits into it. Either way, thank you for going through this tutorial and good luck going forward! Authors: Mickey Li (2022) (mickey.li@bristol.ac.uk) Arthur Richards (2021) (arthur.richards@bristol.ac.uk)","title":"9. Conclusion and Next Steps"},{"location":"tutorial/conclusion/#conclusion-and-next-steps","text":"Congratulations! You have finished the fenswood volcano tutorial on writing your own MAVLINK and ROS2 compatible controller. Hopefully now you have learnt and understood how Mavlink is used to communicate to the drone and how to use ROS to control the drone with Mavlink. You should have also seen a number of different ways of organising your code in a more modular fashion to allow greater flexibitiliy and reliability in your implementations. Finally we showed how you might add Perception through the use of OpenCV in order to autonomously control your drone if you so wish! At this point, you should have enough knowledge to be able to create a controller which can solve the task in a simple way. However, you have probably noticed that there's probably a lot more going on under the surface. So for those wanting to do some more complex tasks, you may be interested in learning a bit more about the underlying simulation. For you, I would recommend carrying on to the Advanced Tutorial. The advanced tutorial will more formally introduce you to the Starling simulation system that you have been using and how your ROS controller fits into it. Either way, thank you for going through this tutorial and good luck going forward! Authors: Mickey Li (2022) (mickey.li@bristol.ac.uk) Arthur Richards (2021) (arthur.richards@bristol.ac.uk)","title":"Conclusion and Next Steps"},{"location":"tutorial/drone_control/","text":"Controlling an Ardupilot drone using MAVLINK over ROS \u00b6 Back to tutorial contents Introduction \u00b6 The application includes a representation of the Ardupilot copter autopilot, a free open-source product in common use in aerial robotics both commercially and in research. Instead of running on a physical autopilot like the Pixhawk , the application uses its simulation capability to run it on your computer. Hence you must learn the 'fly the autopilot'. While the standard interface for the drone is MAVLINK , you will interact using ROS, with the conversion handled by the MAVROS package . Example steps \u00b6 These are the steps performed by the example code. All versions use these same steps. To follow along, I recommend running the old_school version using docker-compose -f docker-compose-old-school.yml up --build and then using foxglove (see Introspecting ROS ). You should see reports on the ROS logs about progress through the steps. Wait for the autopilot to initialize, indicated by a system_status value of 3, MAV_STATE_STANDBY , on the /vehicle_1/mavros/state ROS topic. Request regular updates on global (GPS) position. While most off-the-shelf control software takes care of this, our code needs to explicitly request this information from the autopilot. It is done by sending a custom MAVLINK message using the /vehicle_1/mavros/cmd/command ROS service. There is also a local position available, in Cartesian coordinates relative to the home position. This has some advantages, especially for altitude, but would take more work given we need to work with latitude and longitude. Change flight mode to Guided , meaning that the drone will track a position command from our software. Ardupilot provides lots of different flight modes such as: Stabilise pilot flies using joysticks, everything else ignored Loiter drone uses GPS to hold position, with movements commanded by pilot using joysticks Land drone lands at current location RTL drone goes back to home position and lands Auto drone follows a set of uploaded mission commands Although you can change mode using software, try not to do it too often. One of the safety procedures is for the pilot to take control by changing to Stabilise or Loiter mode, and that becomes harder if your software keeps trying to change back. Arm the drone . This stage starts the motors spinning, hence you only want to do it right before take-off. It can be done by software or by the pilot using joysticks. Arming involves certain checks of things like GPS stability and position estimation, which sometimes take about a minute to settle after powering up. Hence you can expect to need a few goes before the drone successfuly arms. Think about safety when deciding how to arm. You must not start the motors spinning unless you're sure there is no-one working on the drone, e.g. completing the battery fitting. In the simulated examples, the software does it as soon as the drone is ready. In practice, you might want pilot confirmation, or just leave it to the pilot themselves. Take-off! This is a simple software command including a specified target altitude. If you don't take off within a few seconds of arming, the drone will automatically disarm, for safety reasons. Climb, waiting for the drone to get close to the target altitude. Use the information on the /vehicle_1/mavros/global_position topics to monitor progress. The drone will accept a new setpoint at any altitude. However, for the safety of those likely to be near the takeoff point, it is undesirable for the drone to do anything other than climb straight up at first. Altitude is a surprisingly complex topic. It can be expressed relative to mean sea level, to a standardized Earth shape model, to the location where you armed the drone, or to the local atmosphere using air pressure. These can be many tens of metres different to each other. Solutions are available but I find them rather complicated. Instead I recommend pragmatic solutions like using relative information and calculated correction factors, as we are not flying far. Note there is also a helpful-looking /vehicle_1/mavros/global_position/rel_alt topic that I have not tried yet. Move the drone by sending a target, in terms of latitude, longitude and altitude, over the /vehicle_1/mavros/setpoint_position/global topic . Note the altitude issues described above really bite here. The position input uses a different altitude convention to the GPS output. You can also command the drone to a fixed velocity instead of a position, using the /vehicle_1/mavros/setpoint_velocity/cmd_vel_unstamped topic . Helpfully, this is a ROS Twist message which is a standard for movement commands. Wait for the drone to reach its target, or get close enough, by monitoring the /vehicle_1/mavros/global_position topics again. Calculating distance between two latitude and longitude pairs needs a little work. In the examples, 'close' means the numbers are nearly the same, so the flight is not very accurate. Also, the example doesn't check the velocity, so the drone tends to shoot through the target rather than stabilise at it. Send the drone back to land at its take-off location, by changing to RTL mode. The example just stops after sending the RTL mode command. Back to tutorial contents Exercises \u00b6 All exercises work using the old_school code so run the simulation using docker-compose -f 1_old_school/docker-compose-old-school.yml up --build . Run the simulation and watch it progress using https://studio.foxglove.dev . Use the teleoperation buttons (the little gamepad-like panels provided in the example layout, described in Introspecting ROS ) to interrupt the flight during climb or movement. Play around with the teleoperation buttons to explore how they work, with careful attention to the relevant frame of reference. Edit the panel settings and see what difference they make. Interrupt a simulation again and add a Publisher panel in Foxglove. Publish messages to the /vehicle_1/mavros/setpoint_velocity/cmd_vel_unstamped topic and see how the drone responds. Interrupt a simulation and use a Publisher panel to send messages to the /vehicle_1/mavros/setpoint_position/global topic. Try sending different latitude and longitude locations from the project briefing document. Note due to a bug somewhere, you'll need to delete the seq line in the publisher panel to get this to work. Interrupt a simulation and use a combination of the gamepad and the setpoint publisher to land the drone at or near the target. Use the /vehicle_1/gimbal_tilt_cmd publisher to move the camera, with 0 being horizontal and 1.57 being straight downwards. Back to tutorial contents","title":"2. Controlling a Drone using Mavlink Over ROS"},{"location":"tutorial/drone_control/#controlling-an-ardupilot-drone-using-mavlink-over-ros","text":"Back to tutorial contents","title":"Controlling an Ardupilot drone using MAVLINK over ROS"},{"location":"tutorial/drone_control/#introduction","text":"The application includes a representation of the Ardupilot copter autopilot, a free open-source product in common use in aerial robotics both commercially and in research. Instead of running on a physical autopilot like the Pixhawk , the application uses its simulation capability to run it on your computer. Hence you must learn the 'fly the autopilot'. While the standard interface for the drone is MAVLINK , you will interact using ROS, with the conversion handled by the MAVROS package .","title":"Introduction"},{"location":"tutorial/drone_control/#example-steps","text":"These are the steps performed by the example code. All versions use these same steps. To follow along, I recommend running the old_school version using docker-compose -f docker-compose-old-school.yml up --build and then using foxglove (see Introspecting ROS ). You should see reports on the ROS logs about progress through the steps. Wait for the autopilot to initialize, indicated by a system_status value of 3, MAV_STATE_STANDBY , on the /vehicle_1/mavros/state ROS topic. Request regular updates on global (GPS) position. While most off-the-shelf control software takes care of this, our code needs to explicitly request this information from the autopilot. It is done by sending a custom MAVLINK message using the /vehicle_1/mavros/cmd/command ROS service. There is also a local position available, in Cartesian coordinates relative to the home position. This has some advantages, especially for altitude, but would take more work given we need to work with latitude and longitude. Change flight mode to Guided , meaning that the drone will track a position command from our software. Ardupilot provides lots of different flight modes such as: Stabilise pilot flies using joysticks, everything else ignored Loiter drone uses GPS to hold position, with movements commanded by pilot using joysticks Land drone lands at current location RTL drone goes back to home position and lands Auto drone follows a set of uploaded mission commands Although you can change mode using software, try not to do it too often. One of the safety procedures is for the pilot to take control by changing to Stabilise or Loiter mode, and that becomes harder if your software keeps trying to change back. Arm the drone . This stage starts the motors spinning, hence you only want to do it right before take-off. It can be done by software or by the pilot using joysticks. Arming involves certain checks of things like GPS stability and position estimation, which sometimes take about a minute to settle after powering up. Hence you can expect to need a few goes before the drone successfuly arms. Think about safety when deciding how to arm. You must not start the motors spinning unless you're sure there is no-one working on the drone, e.g. completing the battery fitting. In the simulated examples, the software does it as soon as the drone is ready. In practice, you might want pilot confirmation, or just leave it to the pilot themselves. Take-off! This is a simple software command including a specified target altitude. If you don't take off within a few seconds of arming, the drone will automatically disarm, for safety reasons. Climb, waiting for the drone to get close to the target altitude. Use the information on the /vehicle_1/mavros/global_position topics to monitor progress. The drone will accept a new setpoint at any altitude. However, for the safety of those likely to be near the takeoff point, it is undesirable for the drone to do anything other than climb straight up at first. Altitude is a surprisingly complex topic. It can be expressed relative to mean sea level, to a standardized Earth shape model, to the location where you armed the drone, or to the local atmosphere using air pressure. These can be many tens of metres different to each other. Solutions are available but I find them rather complicated. Instead I recommend pragmatic solutions like using relative information and calculated correction factors, as we are not flying far. Note there is also a helpful-looking /vehicle_1/mavros/global_position/rel_alt topic that I have not tried yet. Move the drone by sending a target, in terms of latitude, longitude and altitude, over the /vehicle_1/mavros/setpoint_position/global topic . Note the altitude issues described above really bite here. The position input uses a different altitude convention to the GPS output. You can also command the drone to a fixed velocity instead of a position, using the /vehicle_1/mavros/setpoint_velocity/cmd_vel_unstamped topic . Helpfully, this is a ROS Twist message which is a standard for movement commands. Wait for the drone to reach its target, or get close enough, by monitoring the /vehicle_1/mavros/global_position topics again. Calculating distance between two latitude and longitude pairs needs a little work. In the examples, 'close' means the numbers are nearly the same, so the flight is not very accurate. Also, the example doesn't check the velocity, so the drone tends to shoot through the target rather than stabilise at it. Send the drone back to land at its take-off location, by changing to RTL mode. The example just stops after sending the RTL mode command. Back to tutorial contents","title":"Example steps"},{"location":"tutorial/drone_control/#exercises","text":"All exercises work using the old_school code so run the simulation using docker-compose -f 1_old_school/docker-compose-old-school.yml up --build . Run the simulation and watch it progress using https://studio.foxglove.dev . Use the teleoperation buttons (the little gamepad-like panels provided in the example layout, described in Introspecting ROS ) to interrupt the flight during climb or movement. Play around with the teleoperation buttons to explore how they work, with careful attention to the relevant frame of reference. Edit the panel settings and see what difference they make. Interrupt a simulation again and add a Publisher panel in Foxglove. Publish messages to the /vehicle_1/mavros/setpoint_velocity/cmd_vel_unstamped topic and see how the drone responds. Interrupt a simulation and use a Publisher panel to send messages to the /vehicle_1/mavros/setpoint_position/global topic. Try sending different latitude and longitude locations from the project briefing document. Note due to a bug somewhere, you'll need to delete the seq line in the publisher panel to get this to work. Interrupt a simulation and use a combination of the gamepad and the setpoint publisher to land the drone at or near the target. Use the /vehicle_1/gimbal_tilt_cmd publisher to move the camera, with 0 being horizontal and 1.57 being straight downwards. Back to tutorial contents","title":"Exercises"},{"location":"tutorial/finite_state/","text":"Finite state machine \u00b6 Back to tutorial contents Introduction \u00b6 Our control flow is relatively simple in this example, just carrying on regardless. As solutions grow in complexity and the number of execution paths increases, it becomes much harder to write such control logic as code. You end up with loads of nested if statements and repeated tests. A common approach to handling this is to implement the logic as a finite state machine . The figure above shows an implementation of our control flow as a finite state machine. The ovals represent the six states and the system must be in one of these at all times. The arrows denote transitions . Where an arrow has text, that represents the condition for making that transition. If an arrow has now text, that represents 'all other cases'. The system will always start in the init state, moving to arming if the reported status reaches 'standby' (value 3) and remaining in init otherwise. In arming , arm commands will regularly be sent. If the drone takes too long to respond, the system will move to exit state (now handling the timeout cases properly), or if it does successfuly arm, it will move to climbing (issuing the take-off command on the transition), or stay in arming otherwise. From climbing it will send the target command and move to on_way on reaching altitude, move to landing if too much time elapses, or remain climbing otherwise. From the on_way state, either timing out or reaching the target will trigger a move to landing . The landing state does nothing more than issue an \"RTL\" command and then immediately move state to exit , from where there is no further change as the only transition out is to stay in exit . Back to tutorial contents Example code \u00b6 To run this example, use the command: docker-compose -f 4_finite_state/docker-compose-finite-state.yml up --build The key file is fenswood_drone_controller/fenswood_drone_controller/controller_finite_state.py . The remainder of this section describes how it works. As ever, only the changes from the previous modular version are highlighted. import rclpy # type: ignore from rclpy.node import Node # import message definitions for receiving status and position from mavros_msgs.msg import State # type: ignore from sensor_msgs.msg import NavSatFix # type: ignore # import message definition for sending setpoint from geographic_msgs.msg import GeoPoseStamped # type: ignore # import service definitions for changing mode, arming, take-off and generic command from mavros_msgs.srv import SetMode, CommandBool, CommandTOL, CommandLong # type: ignore class FenswoodDroneController(Node): def __init__(self): super().__init__('example_controller') self.last_status = None # global for last received status message self.last_pos = None # global for last received position message self.init_alt = None # global for global altitude at start self.last_alt_rel = None # global for last altitude relative to start # create service clients for long command (datastream requests)... self.cmd_cli = self.create_client(CommandLong, 'mavros/cmd/command') while not self.cmd_cli.wait_for_service(timeout_sec=1.0): self.get_logger().info('command_int service not available, waiting again...') # ... for mode changes ... self.mode_cli = self.create_client(SetMode, 'mavros/set_mode') while not self.mode_cli.wait_for_service(timeout_sec=1.0): self.get_logger().info('set_mode service not available, waiting again...') # ... for arming ... self.arm_cli = self.create_client(CommandBool, 'mavros/cmd/arming') while not self.arm_cli.wait_for_service(timeout_sec=1.0): self.get_logger().info('arming service not available, waiting again...') # ... and for takeoff self.takeoff_cli = self.create_client(CommandTOL, 'mavros/cmd/takeoff') while not self.takeoff_cli.wait_for_service(timeout_sec=1.0): self.get_logger().info('takeoff service not available, waiting again...') # create publisher for setpoint self.target_pub = self.create_publisher(GeoPoseStamped, 'mavros/setpoint_position/global', 10) # and make a placeholder for the last sent target self.last_target = GeoPoseStamped() # initial state for finite state machine self.control_state = 'init' # timer for time spent in each state self.state_timer = 0 The last two statements are new to the __init__ controller constructor. self.control_state will record the current state of the system and, as described in the logic above, will be init to begin. the state_timer will hold the time spent in each state, facilitating the timeout transitions (see later). # on receiving status message, save it to global def state_callback(self,msg): self.last_status = msg self.get_logger().debug('Mode: {}. Armed: {}. System status: {}'.format(msg.mode,msg.armed,msg.system_status)) # on receiving positon message, save it to global def position_callback(self,msg): # determine altitude relative to start if self.init_alt: self.last_alt_rel = msg.altitude - self.init_alt self.last_pos = msg self.get_logger().debug('Drone at {}N,{}E altitude {}m'.format(msg.latitude, msg.longitude, self.last_alt_rel)) def wait_for_new_status(self): \"\"\" Wait for new state message to be received. These are sent at 1Hz so calling this is roughly equivalent to one second delay. \"\"\" if self.last_status: # if had a message before, wait for higher timestamp last_stamp = self.last_status.header.stamp.sec for try_wait in range(60): rclpy.spin_once(self) if self.last_status.header.stamp.sec > last_stamp: break else: # if never had a message, just wait for first one for try_wait in range(60): if self.last_status: break rclpy.spin_once(self) def request_data_stream(self,msg_id,msg_interval): cmd_req = CommandLong.Request() cmd_req.command = 511 cmd_req.param1 = float(msg_id) cmd_req.param2 = float(msg_interval) future = self.cmd_cli.call_async(cmd_req) rclpy.spin_until_future_complete(self, future) # wait for response def change_mode(self,new_mode): mode_req = SetMode.Request() mode_req.custom_mode = new_mode future = self.mode_cli.call_async(mode_req) rclpy.spin_until_future_complete(self, future) # wait for response def arm_request(self): arm_req = CommandBool.Request() arm_req.value = True future = self.arm_cli.call_async(arm_req) rclpy.spin_until_future_complete(self, future) def takeoff(self,target_alt): takeoff_req = CommandTOL.Request() takeoff_req.altitude = target_alt future = self.takeoff_cli.call_async(takeoff_req) rclpy.spin_until_future_complete(self, future) def flyto(self,lat,lon,alt): self.last_target.pose.position.latitude = lat self.last_target.pose.position.longitude = lon self.last_target.pose.position.altitude = alt self.target_pub.publish(self.last_target) self.get_logger().info('Sent drone to {}N, {}E, altitude {}m'.format(lat,lon,alt)) The above utilities are unchanged - they will be called by different logic, but their operation remains the same. A really good style would probably package these up in a separate file as a module, as they are quite distinct and self-contained. def state_transition(self): if self.control_state =='init': if self.last_status.system_status==3: self.get_logger().info('Drone initialized') # send command to request regular position updates self.request_data_stream(33, 1000000) self.get_logger().info('Requested position stream') # change mode to GUIDED self.change_mode(\"GUIDED\") self.get_logger().info('Request sent for GUIDED mode.') # move on to arming return('arming') else: return('init') elif self.control_state == 'arming': if self.last_status.armed: self.get_logger().info('Arming successful') # armed - grab init alt for relative working if self.last_pos: self.init_alt = self.last_pos.altitude # send takeoff command self.takeoff(20.0) self.get_logger().info('Takeoff request sent.') return('climbing') elif self.state_timer > 60: # timeout self.get_logger().error('Failed to arm') return('exit') else: self.arm_request() self.get_logger().info('Arming request sent.') return('arming') elif self.control_state == 'climbing': if self.last_alt_rel > 19.0: self.get_logger().info('Close enough to flight altitude') # move drone by sending setpoint message self.flyto(51.423, -2.671, self.init_alt - 30.0) # unexplained correction factor on altitude return('on_way') elif self.state_timer > 60: # timeout self.get_logger().error('Failed to reach altitude') return('landing') else: self.get_logger().info('Climbing, altitude {}m'.format(self.last_alt_rel)) return('climbing') elif self.control_state == 'on_way': d_lon = self.last_pos.longitude - self.last_target.pose.position.longitude d_lat = self.last_pos.latitude - self.last_target.pose.position.latitude if (abs(d_lon) < 0.0001) & (abs(d_lat) < 0.0001): self.get_logger().info('Close enough to target delta={},{}'.format(d_lat,d_lon)) return('landing') elif self.state_timer > 60: # timeout self.get_logger().error('Failed to reach target') return('landing') else: self.get_logger().info('Target error {},{}'.format(d_lat,d_lon)) return('on_way') elif self.control_state == 'landing': # return home and land self.change_mode(\"RTL\") self.get_logger().info('Request sent for RTL mode.') return('exit') elif self.control_state == 'exit': # nothing else to do return('exit') THe state_transition function implements the logic described in the text and diagram above. The structure is typical of a finite state machine implementation: each finite state has its own 'clause' in a big if...elif...elif statement (C would do it as a switch...case... ). Thus it is easy to see where the code for each state lives, and to make changes if needed. Note the actions ( e.g. sending commands) typically appear in the transitions. For example, in the init state, the datastream request and the change of mode appear right before the state is updated to arming . Then in the arming state, the actual command to arm appears in the (null) transition to stay in arming . Hence the arm command will be issued over and over until success is detected. def run(self): # set up two subscribers, one for vehicle state... state_sub = self.create_subscription(State, 'mavros/state', self.state_callback, 10) # ...and the other for global position pos_sub = self.create_subscription(NavSatFix, 'mavros/global_position/global', self.position_callback, 10) for try_loop in range(600): if rclpy.ok(): self.wait_for_new_status() new_state = self.state_transition() if new_state == self.control_state: self.state_timer = self.state_timer + 1 else: self.state_timer = 0 self.control_state = new_state self.get_logger().info('Controller state: {} for {} steps'.format(self.control_state, self.state_timer)) With each iteration of this code, the run() method does less and less. With the control logic now handled in its own state_transition function, run just starts the subscribers as before and manages the state and the timer. The self.state_timer counter is incremented each time, unless the state changes in which case it is reset. def main(args=None): rclpy.init(args=args) controller_node = FenswoodDroneController() controller_node.run() if __name__ == '__main__': main() Main and the Python bit at the end remain unchanged. Exercises \u00b6 All exercises work involve editing the file controller_finite_state.py . Add a second target and fly to it only if you reach the first target within a limited time, or (b) if you fail to reach the first target in time. Add an extra initial target, but make it very far away. When you don't reach it in a sensible time, divert back to your original target. Add a human 'approve' input. When you get to altitude, ask the operator (in the log) if they are happy to proceed, and fly to the target only if they approve. For input, you can define your own ROS topic and have them publish through Foxglove, or re-purpose the tele-op gamepad buttons to publish to a different topic, or just ask the operator to wiggle the camera. Test all cases you can think of: operator says 'yes' when asked, operator says 'no' when asked, operator says nothing, operator has said 'yes' but before being asked, etc. Add a human 'pause' input. Define a button, topic or some other signal, and make the drone stop and hover if the operator requests it. There are lots of ways of implementing this, including mode changes or extra control logic. Don't forget you can connect QGroundControl to the simulation via localhost, TCP port 5761, if you want the operator to interact that way. Back to tutorial contents","title":"6. Adding A Finite State Machine"},{"location":"tutorial/finite_state/#finite-state-machine","text":"Back to tutorial contents","title":"Finite state machine"},{"location":"tutorial/finite_state/#introduction","text":"Our control flow is relatively simple in this example, just carrying on regardless. As solutions grow in complexity and the number of execution paths increases, it becomes much harder to write such control logic as code. You end up with loads of nested if statements and repeated tests. A common approach to handling this is to implement the logic as a finite state machine . The figure above shows an implementation of our control flow as a finite state machine. The ovals represent the six states and the system must be in one of these at all times. The arrows denote transitions . Where an arrow has text, that represents the condition for making that transition. If an arrow has now text, that represents 'all other cases'. The system will always start in the init state, moving to arming if the reported status reaches 'standby' (value 3) and remaining in init otherwise. In arming , arm commands will regularly be sent. If the drone takes too long to respond, the system will move to exit state (now handling the timeout cases properly), or if it does successfuly arm, it will move to climbing (issuing the take-off command on the transition), or stay in arming otherwise. From climbing it will send the target command and move to on_way on reaching altitude, move to landing if too much time elapses, or remain climbing otherwise. From the on_way state, either timing out or reaching the target will trigger a move to landing . The landing state does nothing more than issue an \"RTL\" command and then immediately move state to exit , from where there is no further change as the only transition out is to stay in exit . Back to tutorial contents","title":"Introduction"},{"location":"tutorial/finite_state/#example-code","text":"To run this example, use the command: docker-compose -f 4_finite_state/docker-compose-finite-state.yml up --build The key file is fenswood_drone_controller/fenswood_drone_controller/controller_finite_state.py . The remainder of this section describes how it works. As ever, only the changes from the previous modular version are highlighted. import rclpy # type: ignore from rclpy.node import Node # import message definitions for receiving status and position from mavros_msgs.msg import State # type: ignore from sensor_msgs.msg import NavSatFix # type: ignore # import message definition for sending setpoint from geographic_msgs.msg import GeoPoseStamped # type: ignore # import service definitions for changing mode, arming, take-off and generic command from mavros_msgs.srv import SetMode, CommandBool, CommandTOL, CommandLong # type: ignore class FenswoodDroneController(Node): def __init__(self): super().__init__('example_controller') self.last_status = None # global for last received status message self.last_pos = None # global for last received position message self.init_alt = None # global for global altitude at start self.last_alt_rel = None # global for last altitude relative to start # create service clients for long command (datastream requests)... self.cmd_cli = self.create_client(CommandLong, 'mavros/cmd/command') while not self.cmd_cli.wait_for_service(timeout_sec=1.0): self.get_logger().info('command_int service not available, waiting again...') # ... for mode changes ... self.mode_cli = self.create_client(SetMode, 'mavros/set_mode') while not self.mode_cli.wait_for_service(timeout_sec=1.0): self.get_logger().info('set_mode service not available, waiting again...') # ... for arming ... self.arm_cli = self.create_client(CommandBool, 'mavros/cmd/arming') while not self.arm_cli.wait_for_service(timeout_sec=1.0): self.get_logger().info('arming service not available, waiting again...') # ... and for takeoff self.takeoff_cli = self.create_client(CommandTOL, 'mavros/cmd/takeoff') while not self.takeoff_cli.wait_for_service(timeout_sec=1.0): self.get_logger().info('takeoff service not available, waiting again...') # create publisher for setpoint self.target_pub = self.create_publisher(GeoPoseStamped, 'mavros/setpoint_position/global', 10) # and make a placeholder for the last sent target self.last_target = GeoPoseStamped() # initial state for finite state machine self.control_state = 'init' # timer for time spent in each state self.state_timer = 0 The last two statements are new to the __init__ controller constructor. self.control_state will record the current state of the system and, as described in the logic above, will be init to begin. the state_timer will hold the time spent in each state, facilitating the timeout transitions (see later). # on receiving status message, save it to global def state_callback(self,msg): self.last_status = msg self.get_logger().debug('Mode: {}. Armed: {}. System status: {}'.format(msg.mode,msg.armed,msg.system_status)) # on receiving positon message, save it to global def position_callback(self,msg): # determine altitude relative to start if self.init_alt: self.last_alt_rel = msg.altitude - self.init_alt self.last_pos = msg self.get_logger().debug('Drone at {}N,{}E altitude {}m'.format(msg.latitude, msg.longitude, self.last_alt_rel)) def wait_for_new_status(self): \"\"\" Wait for new state message to be received. These are sent at 1Hz so calling this is roughly equivalent to one second delay. \"\"\" if self.last_status: # if had a message before, wait for higher timestamp last_stamp = self.last_status.header.stamp.sec for try_wait in range(60): rclpy.spin_once(self) if self.last_status.header.stamp.sec > last_stamp: break else: # if never had a message, just wait for first one for try_wait in range(60): if self.last_status: break rclpy.spin_once(self) def request_data_stream(self,msg_id,msg_interval): cmd_req = CommandLong.Request() cmd_req.command = 511 cmd_req.param1 = float(msg_id) cmd_req.param2 = float(msg_interval) future = self.cmd_cli.call_async(cmd_req) rclpy.spin_until_future_complete(self, future) # wait for response def change_mode(self,new_mode): mode_req = SetMode.Request() mode_req.custom_mode = new_mode future = self.mode_cli.call_async(mode_req) rclpy.spin_until_future_complete(self, future) # wait for response def arm_request(self): arm_req = CommandBool.Request() arm_req.value = True future = self.arm_cli.call_async(arm_req) rclpy.spin_until_future_complete(self, future) def takeoff(self,target_alt): takeoff_req = CommandTOL.Request() takeoff_req.altitude = target_alt future = self.takeoff_cli.call_async(takeoff_req) rclpy.spin_until_future_complete(self, future) def flyto(self,lat,lon,alt): self.last_target.pose.position.latitude = lat self.last_target.pose.position.longitude = lon self.last_target.pose.position.altitude = alt self.target_pub.publish(self.last_target) self.get_logger().info('Sent drone to {}N, {}E, altitude {}m'.format(lat,lon,alt)) The above utilities are unchanged - they will be called by different logic, but their operation remains the same. A really good style would probably package these up in a separate file as a module, as they are quite distinct and self-contained. def state_transition(self): if self.control_state =='init': if self.last_status.system_status==3: self.get_logger().info('Drone initialized') # send command to request regular position updates self.request_data_stream(33, 1000000) self.get_logger().info('Requested position stream') # change mode to GUIDED self.change_mode(\"GUIDED\") self.get_logger().info('Request sent for GUIDED mode.') # move on to arming return('arming') else: return('init') elif self.control_state == 'arming': if self.last_status.armed: self.get_logger().info('Arming successful') # armed - grab init alt for relative working if self.last_pos: self.init_alt = self.last_pos.altitude # send takeoff command self.takeoff(20.0) self.get_logger().info('Takeoff request sent.') return('climbing') elif self.state_timer > 60: # timeout self.get_logger().error('Failed to arm') return('exit') else: self.arm_request() self.get_logger().info('Arming request sent.') return('arming') elif self.control_state == 'climbing': if self.last_alt_rel > 19.0: self.get_logger().info('Close enough to flight altitude') # move drone by sending setpoint message self.flyto(51.423, -2.671, self.init_alt - 30.0) # unexplained correction factor on altitude return('on_way') elif self.state_timer > 60: # timeout self.get_logger().error('Failed to reach altitude') return('landing') else: self.get_logger().info('Climbing, altitude {}m'.format(self.last_alt_rel)) return('climbing') elif self.control_state == 'on_way': d_lon = self.last_pos.longitude - self.last_target.pose.position.longitude d_lat = self.last_pos.latitude - self.last_target.pose.position.latitude if (abs(d_lon) < 0.0001) & (abs(d_lat) < 0.0001): self.get_logger().info('Close enough to target delta={},{}'.format(d_lat,d_lon)) return('landing') elif self.state_timer > 60: # timeout self.get_logger().error('Failed to reach target') return('landing') else: self.get_logger().info('Target error {},{}'.format(d_lat,d_lon)) return('on_way') elif self.control_state == 'landing': # return home and land self.change_mode(\"RTL\") self.get_logger().info('Request sent for RTL mode.') return('exit') elif self.control_state == 'exit': # nothing else to do return('exit') THe state_transition function implements the logic described in the text and diagram above. The structure is typical of a finite state machine implementation: each finite state has its own 'clause' in a big if...elif...elif statement (C would do it as a switch...case... ). Thus it is easy to see where the code for each state lives, and to make changes if needed. Note the actions ( e.g. sending commands) typically appear in the transitions. For example, in the init state, the datastream request and the change of mode appear right before the state is updated to arming . Then in the arming state, the actual command to arm appears in the (null) transition to stay in arming . Hence the arm command will be issued over and over until success is detected. def run(self): # set up two subscribers, one for vehicle state... state_sub = self.create_subscription(State, 'mavros/state', self.state_callback, 10) # ...and the other for global position pos_sub = self.create_subscription(NavSatFix, 'mavros/global_position/global', self.position_callback, 10) for try_loop in range(600): if rclpy.ok(): self.wait_for_new_status() new_state = self.state_transition() if new_state == self.control_state: self.state_timer = self.state_timer + 1 else: self.state_timer = 0 self.control_state = new_state self.get_logger().info('Controller state: {} for {} steps'.format(self.control_state, self.state_timer)) With each iteration of this code, the run() method does less and less. With the control logic now handled in its own state_transition function, run just starts the subscribers as before and manages the state and the timer. The self.state_timer counter is incremented each time, unless the state changes in which case it is reset. def main(args=None): rclpy.init(args=args) controller_node = FenswoodDroneController() controller_node.run() if __name__ == '__main__': main() Main and the Python bit at the end remain unchanged.","title":"Example code"},{"location":"tutorial/finite_state/#exercises","text":"All exercises work involve editing the file controller_finite_state.py . Add a second target and fly to it only if you reach the first target within a limited time, or (b) if you fail to reach the first target in time. Add an extra initial target, but make it very far away. When you don't reach it in a sensible time, divert back to your original target. Add a human 'approve' input. When you get to altitude, ask the operator (in the log) if they are happy to proceed, and fly to the target only if they approve. For input, you can define your own ROS topic and have them publish through Foxglove, or re-purpose the tele-op gamepad buttons to publish to a different topic, or just ask the operator to wiggle the camera. Test all cases you can think of: operator says 'yes' when asked, operator says 'no' when asked, operator says nothing, operator has said 'yes' but before being asked, etc. Add a human 'pause' input. Define a button, topic or some other signal, and make the drone stop and hover if the operator requests it. There are lots of ways of implementing this, including mode changes or extra control logic. Don't forget you can connect QGroundControl to the simulation via localhost, TCP port 5761, if you want the operator to interact that way. Back to tutorial contents","title":"Exercises"},{"location":"tutorial/getting_started/","text":"Getting Started \u00b6 Back to tutorial contents Prerequisites \u00b6 You will need to install git to access the software and docker to run it. These are supported on Windows, Mac and Linux. I also recommend Visual Studio Code as an editing environment with easy access to terminal windows. Getting the template \u00b6 Navigate to a suitable file folder on your computer and run git clone https://github.com/StarlingUAS/fenswood_volcano_template.git Running a first simulation \u00b6 For Docker simulation on either Linux or Windows, open a terminal, navigate to your cloned folder and run docker-compose up --build . This could take a very long time on your first attempt, perhaps as much as half an hour. It has a lot of stuff to download. You should eventually see an awful lot of stuff flying by in the terminal window. The excerpt below is just a short example. controller_1 | [controller-1] [INFO] [1641487809.030179200] [vehicle_1.example_controller]: Arm request sent controller_1 | [controller-1] [INFO] [1641487809.031134000] [vehicle_1.example_controller]: Controller state: arming for 13 steps mavros_1 | [run_ros1.sh-1] [ERROR] [1641487809.032953700]: FCU: PreArm: Bad GPS Position controller_1 | [image_processor-2] [INFO] [1641487809.057483100] [vehicle_1.image_processor]: Got an image of 480 x 640 Watching it fly \u00b6 If that's happening, open a web browser and open http://localhost:8080 . You should see a Gazebo window with a green field, a couple of cones, and a drone. Watch long enough and the drone should take-off. Watch even longer and it should return. Introspecting ROS \u00b6 Open another web browser and navigate to https://studio.foxglove.dev . Select Open Connection and enter ws://localhost:9090 in the URL box, if it's not already there. This gets you into Foxglove, a powerful dashboard for ROS. To get started, click the Layouts button (second down on the left hand menu) and then the Import Layout button at the top of the panel that opens. Navigate to your fenswood_volcano_template folder and select fenswood_example.json . Click the Layouts button again to close the panel and maximize the rest of the dashboard. You should see logs, drone status and position, and the drone camera feed, among other things. Back to tutorial contents Exercise \u00b6 Have a play around. Watch flights through both Gazebo and Foxglove and explore their interfaces. When finished, stop everything with Ctrl+C in the terminal where you ran docker-compose .","title":"1. Getting Started"},{"location":"tutorial/getting_started/#getting-started","text":"Back to tutorial contents","title":"Getting Started"},{"location":"tutorial/getting_started/#prerequisites","text":"You will need to install git to access the software and docker to run it. These are supported on Windows, Mac and Linux. I also recommend Visual Studio Code as an editing environment with easy access to terminal windows.","title":"Prerequisites"},{"location":"tutorial/getting_started/#getting-the-template","text":"Navigate to a suitable file folder on your computer and run git clone https://github.com/StarlingUAS/fenswood_volcano_template.git","title":"Getting the template"},{"location":"tutorial/getting_started/#running-a-first-simulation","text":"For Docker simulation on either Linux or Windows, open a terminal, navigate to your cloned folder and run docker-compose up --build . This could take a very long time on your first attempt, perhaps as much as half an hour. It has a lot of stuff to download. You should eventually see an awful lot of stuff flying by in the terminal window. The excerpt below is just a short example. controller_1 | [controller-1] [INFO] [1641487809.030179200] [vehicle_1.example_controller]: Arm request sent controller_1 | [controller-1] [INFO] [1641487809.031134000] [vehicle_1.example_controller]: Controller state: arming for 13 steps mavros_1 | [run_ros1.sh-1] [ERROR] [1641487809.032953700]: FCU: PreArm: Bad GPS Position controller_1 | [image_processor-2] [INFO] [1641487809.057483100] [vehicle_1.image_processor]: Got an image of 480 x 640","title":"Running a first simulation"},{"location":"tutorial/getting_started/#watching-it-fly","text":"If that's happening, open a web browser and open http://localhost:8080 . You should see a Gazebo window with a green field, a couple of cones, and a drone. Watch long enough and the drone should take-off. Watch even longer and it should return.","title":"Watching it fly"},{"location":"tutorial/getting_started/#introspecting-ros","text":"Open another web browser and navigate to https://studio.foxglove.dev . Select Open Connection and enter ws://localhost:9090 in the URL box, if it's not already there. This gets you into Foxglove, a powerful dashboard for ROS. To get started, click the Layouts button (second down on the left hand menu) and then the Import Layout button at the top of the panel that opens. Navigate to your fenswood_volcano_template folder and select fenswood_example.json . Click the Layouts button again to close the panel and maximize the rest of the dashboard. You should see logs, drone status and position, and the drone camera feed, among other things. Back to tutorial contents","title":"Introspecting ROS"},{"location":"tutorial/getting_started/#exercise","text":"Have a play around. Watch flights through both Gazebo and Foxglove and explore their interfaces. When finished, stop everything with Ctrl+C in the terminal where you ran docker-compose .","title":"Exercise"},{"location":"tutorial/local_linux/","text":"docker vscode git For Docker simulation on either Linux or Windows, navigate to cloned folder and run docker-compose up --build . For native development on Linux: - ROS2 Foxy: https://docs.ros.org/en/foxy/Installation/Ubuntu-Install-Debians.html - Weird bug before ROS would work: pip install argcomplete - Colcon: https://docs.ros.org/en/foxy/Tutorials/Colcon-Tutorial.html - Create a workspace, as far as Step 3 (cloning) https://docs.ros.org/en/foxy/Tutorials/Workspace/Creating-A-Workspace.html - Clone https://github.com/arthurrichards77/fenswood_volcano_template into ws/src - Clone https://github.com/mavlink/mavros into ws/src - Pick up again from Step 4 https://docs.ros.org/en/foxy/Tutorials/Workspace/Creating-A-Workspace.html - MAVROS takes forever to build! Got an error about libmavconn - wait and see if that's a problem","title":"Local linux"},{"location":"tutorial/modular/","text":"A more modular controller \u00b6 Back to tutorial contents Introduction \u00b6 In the previous simple class example, a controller class was created, of which the callbacks and the main control thread were methods, and the items of shared data were properties. The class was a child of the ROS Node class meaning that all the ROS functionality was inherited. This made a rather elegant structure - but was only the beginning. In this example, the main steps will be broken out into additional methods of the FenswoodDroneController class, so the main run method can be simpler. The result is a more modular and extensible solution. \"Each module should do one thing well.\" Achieve that, and you can start re-using those modules to do more complex things, also well. Example code \u00b6 To run this example: docker-compose -f 3_modular/docker-compose-modular.yml up --build The key file is fenswood_drone_controller/fenswood_drone_controller/controller_modular.py . Only differences from the first object-oriented solution are highlighted. import rclpy from rclpy.node import Node # import message definitions for receiving status and position from mavros_msgs.msg import State from sensor_msgs.msg import NavSatFix # import message definition for sending setpoint from geographic_msgs.msg import GeoPoseStamped # import service definitions for changing mode, arming, take-off and generic command from mavros_msgs.srv import SetMode, CommandBool, CommandTOL, CommandLong class FenswoodDroneController(Node): def __init__(self): super().__init__('example_controller') self.last_state = None # global for last received status message self.last_pos = None # global for last received position message self.init_alt = None # global for global altitude at start self.last_alt_rel = None # global for last altitude relative to start The code starts off with the same imports and initialization as the simple class implementation . # create service clients for long command (datastream requests)... self.cmd_cli = self.create_client(CommandLong, 'mavros/cmd/command') while not self.cmd_cli.wait_for_service(timeout_sec=1.0): self.get_logger().info('command_int service not available, waiting again...') # ... for mode changes ... self.mode_cli = self.create_client(SetMode, 'mavros/set_mode') while not self.mode_cli.wait_for_service(timeout_sec=1.0): self.get_logger().info('set_mode service not available, waiting again...') # ... for arming ... self.arm_cli = self.create_client(CommandBool, 'mavros/cmd/arming') while not self.arm_cli.wait_for_service(timeout_sec=1.0): self.get_logger().info('arming service not available, waiting again...') # ... and for takeoff self.takeoff_cli = self.create_client(CommandTOL, 'mavros/cmd/takeoff') while not self.takeoff_cli.wait_for_service(timeout_sec=1.0): self.get_logger().info('takeoff service not available, waiting again...') # create publisher for setpoint self.target_pub = self.create_publisher(GeoPoseStamped, 'mavros/setpoint_position/global', 10) # and make a placeholder for the last sent target self.last_target = GeoPoseStamped() Now, all the clients for services and publishing are created in the constructor __init__() . This is so they can be used and re-used by methods coming in a bit. Note the client handles ( e.g. self.takeoff_cli ) are stored as properties of the object, using self . This means thay can be accessed by other methods of the same object, again via self . Only publishers and service callers are included here. Subscribers are still left for the run() method as I don't want stuff to start running until later on. You could have kept these activities in other methods, creating new clients each time something needs to be published or called. However, they take work and delay due to interactions with the ROS ecosystem, so it's better to just get them done once at the start. Arguably, I should have put the wait_for_service calls in run() as well, so an object could be constructed in isolation from ROS if I wanted to. # on receiving status message, save it to global def state_callback(self,msg): self.last_state = msg self.get_logger().debug('Mode: {}. Armed: {}. System status: {}'.format(msg.mode,msg.armed,msg.system_status)) # on receiving positon message, save it to global def position_callback(self,msg): # determine altitude relative to start if self.init_alt: self.last_alt_rel = msg.altitude - self.init_alt self.last_pos = msg self.get_logger().debug('Drone at {}N,{}E altitude {}m'.format(msg.latitude, msg.longitude, self.last_alt_rel)) def wait_for_new_status(self): \"\"\" Wait for new state message to be received. These are sent at 1Hz so calling this is roughly equivalent to one second delay. \"\"\" if self.last_state: # if had a message before, wait for higher timestamp last_stamp = self.last_state.header.stamp.sec for try_wait in range(60): rclpy.spin_once(self) if self.last_state.header.stamp.sec > last_stamp: break else: # if never had a message, just wait for first one for try_wait in range(60): if self.last_state: break rclpy.spin_once(self) Callbacks and the wait_for_status() utility method are unchanged: these are already nice simple functions with clear, distinct purposes. def request_data_stream(self,msg_id,msg_interval): cmd_req = CommandLong.Request() cmd_req.command = 511 cmd_req.param1 = float(msg_id) cmd_req.param2 = float(msg_interval) future = self.cmd_cli.call_async(cmd_req) rclpy.spin_until_future_complete(self, future) # wait for response Above is the first of the new methods to take on a specific task: in the case, requesting a data stream. \"Make sure every module hides something\" is another good guideline . Here, we hide from later software that requesting data involves all this complicated stuff about long commands and service calls. The function takes the desired message msg_id and the message interval msg_interval as arguments so future calls can request different messages and rates. With the relevant service client already set up in the __init__ constructor, we can go straight ahead and call self.cmd_cli.call_async() without the set-up and waiting. def change_mode(self,new_mode): mode_req = SetMode.Request() mode_req.custom_mode = new_mode future = self.mode_cli.call_async(mode_req) rclpy.spin_until_future_complete(self, future) # wait for response Another helper method, change_mode does exactly what it says in the name, again hiding the associated ROS details under a simple Python call. For re-use, callers provide the new_mode as an argument. def arm_request(self): arm_req = CommandBool.Request() arm_req.value = True future = self.arm_cli.call_async(arm_req) rclpy.spin_until_future_complete(self, future) Hopefully the pattern is emerging: each of the steps of our control flow are now going to be single lines, calling the associated methods and hiding the ROS interfaces. arm_request doesn't need any arguments as it always does the same job. def takeoff(self,target_alt): takeoff_req = CommandTOL.Request() takeoff_req.altitude = target_alt future = self.takeoff_cli.call_async(takeoff_req) rclpy.spin_until_future_complete(self, future) def flyto(self,lat,lon,alt): self.last_target.pose.position.latitude = lat self.last_target.pose.position.longitude = lon self.last_target.pose.position.altitude = alt self.target_pub.publish(self.last_target) self.get_logger().info('Sent drone to {}N, {}E, altitude {}m'.format(lat,lon,alt)) Methods for take_off and flyto are hopefully self-explanatory, and show how Python code can just about comment itself if you choose the names clearly. Note that flyto() saves the commanded target to a property last_target for later use. I was trying to follow the Python style guide on function names so flyto really ought to be fly_to . I recommend you adopt a standard and stick to it. For all it can feel pedantic sometimes, it really does help when working on code as a group. def run(self): # set up two subscribers, one for vehicle state... state_sub = self.create_subscription(State, 'mavros/state', self.state_callback, 10) # ...and the other for global position pos_sub = self.create_subscription(NavSatFix, 'mavros/global_position/global', self.position_callback, 10) # first wait for the system status to become 3 \"standby\" # see https://mavlink.io/en/messages/common.html#MAV_STATE for try_standby in range(60): self.wait_for_new_status() if self.last_state.system_status==3: self.get_logger().info('Drone ready for flight') break The run() method starts off just as always, launching the subscriptions and waiting for the right status. # send command to request regular position updates self.request_data_stream(33, 1000000) self.get_logger().info('Requested position stream') # now change mode to GUIDED self.change_mode(\"GUIDED\") self.get_logger().info('Request sent for GUIDED mode.') Now the next two steps, asking for the position data and changing to GUIDED, are just two lines of code plus associated logging. It's much easier to follow the intent than before with the complexity of all the ROS moved to the methods. Why did I not put the get_logger().info() calls in the methods too? Don't know really - I did for flyto but not for the other methods. That inconsistency irks me now, but it made sense at the time. # next, try to arm the drone # keep trying until arming detected in state message, or 60 attempts for try_arm in range(60): self.arm_request() self.get_logger().info('Arming request sent.') self.wait_for_new_status() if self.last_state.armed: self.get_logger().info('Arming successful') # armed - grab init alt for relative working if self.last_pos: self.init_alt = self.last_pos.altitude break else: self.get_logger().error('Failed to arm') The arming step is slightly simpler with just the arm_request call doing the work. # take off and climb to 20.0m at current location self.takeoff(20.0) self.get_logger().info('Takeoff request sent.') Take off is now just one line calling the earlier method, plus a log record. # wait for drone to reach desired altitude, or 60 attempts for try_alt in range(60): self.wait_for_new_status() self.get_logger().info('Climbing, altitude {}m'.format(self.last_alt_rel)) if self.last_alt_rel > 19.0: self.get_logger().info('Close enough to flight altitude') break # move drone by sending setpoint message self.flyto(51.423, -2.671, self.init_alt - 30.0) # unexplained correction factor on altitude Moving the drone is again just a single line. # wait for drone to reach desired position, or timeout after 60 attempts for try_arrive in range(60): self.wait_for_new_status() d_lon = self.last_pos.longitude - self.last_target.pose.position.longitude d_lat = self.last_pos.latitude - self.last_target.pose.position.latitude self.get_logger().info('Target error {},{}'.format(d_lat,d_lon)) if abs(d_lon) < 0.0001: if abs(d_lat) < 0.0001: self.get_logger().info('Close enough to target delta={},{}'.format(d_lat,d_lon)) break Monitoring progress is largely unchanged, apart from using the stored last_target property to check distance. This actually feels clumsy compared to the rest of the code and I will ask you to improve upon it in the exercises. # return home and land self.change_mode(\"RTL\") self.get_logger().info('Request sent for RTL mode.') The change_mode method is used again to head home using RTL. # now just serve out the time until process killed while rclpy.ok(): rclpy.spin_once(self) def main(args=None): rclpy.init(args=args) controller_node = FenswoodDroneController() controller_node.run() if __name__ == '__main__': main() The remainder is unchanged. Back to tutorial contents Exercises \u00b6 All exercises involve editing the file fenswood_drone_controller/fenswood_drone_controller/controller_modular.py Create a method to move the camera. It should publish a message of type std_msgs/Float32 to the /vehicle_1/gimbal_tilt_cmd topic to move the camera, with 0 in the data field being horizontal and 1.57 being straight downwards. Add a method to measure distance (in some simple way) to the last target. Use it to simplify the code in the run() method. Then add a stage to your code that flies to a second target after the first has been reached. None of the methods in the example so far returned a value! If you include a return x statement in the method, you can use x = self.my_method(stuff) to access it. Use return a,b,c and a,b,c = self.my_method(stuff) to return multiple values , if that's required. Add a request for message 32, LOCAL_POSITION_NED . Observe what happens on foxglove looking at topic /vehicle_1/mavros/local_position/pose . In the code, add a subscriber to /vehicle_1/mavros/local_position/pose and try using this local altitude to track climb progress in run() . Back to tutorial contents","title":"5. A More Modular Controller"},{"location":"tutorial/modular/#a-more-modular-controller","text":"Back to tutorial contents","title":"A more modular controller"},{"location":"tutorial/modular/#introduction","text":"In the previous simple class example, a controller class was created, of which the callbacks and the main control thread were methods, and the items of shared data were properties. The class was a child of the ROS Node class meaning that all the ROS functionality was inherited. This made a rather elegant structure - but was only the beginning. In this example, the main steps will be broken out into additional methods of the FenswoodDroneController class, so the main run method can be simpler. The result is a more modular and extensible solution. \"Each module should do one thing well.\" Achieve that, and you can start re-using those modules to do more complex things, also well.","title":"Introduction"},{"location":"tutorial/modular/#example-code","text":"To run this example: docker-compose -f 3_modular/docker-compose-modular.yml up --build The key file is fenswood_drone_controller/fenswood_drone_controller/controller_modular.py . Only differences from the first object-oriented solution are highlighted. import rclpy from rclpy.node import Node # import message definitions for receiving status and position from mavros_msgs.msg import State from sensor_msgs.msg import NavSatFix # import message definition for sending setpoint from geographic_msgs.msg import GeoPoseStamped # import service definitions for changing mode, arming, take-off and generic command from mavros_msgs.srv import SetMode, CommandBool, CommandTOL, CommandLong class FenswoodDroneController(Node): def __init__(self): super().__init__('example_controller') self.last_state = None # global for last received status message self.last_pos = None # global for last received position message self.init_alt = None # global for global altitude at start self.last_alt_rel = None # global for last altitude relative to start The code starts off with the same imports and initialization as the simple class implementation . # create service clients for long command (datastream requests)... self.cmd_cli = self.create_client(CommandLong, 'mavros/cmd/command') while not self.cmd_cli.wait_for_service(timeout_sec=1.0): self.get_logger().info('command_int service not available, waiting again...') # ... for mode changes ... self.mode_cli = self.create_client(SetMode, 'mavros/set_mode') while not self.mode_cli.wait_for_service(timeout_sec=1.0): self.get_logger().info('set_mode service not available, waiting again...') # ... for arming ... self.arm_cli = self.create_client(CommandBool, 'mavros/cmd/arming') while not self.arm_cli.wait_for_service(timeout_sec=1.0): self.get_logger().info('arming service not available, waiting again...') # ... and for takeoff self.takeoff_cli = self.create_client(CommandTOL, 'mavros/cmd/takeoff') while not self.takeoff_cli.wait_for_service(timeout_sec=1.0): self.get_logger().info('takeoff service not available, waiting again...') # create publisher for setpoint self.target_pub = self.create_publisher(GeoPoseStamped, 'mavros/setpoint_position/global', 10) # and make a placeholder for the last sent target self.last_target = GeoPoseStamped() Now, all the clients for services and publishing are created in the constructor __init__() . This is so they can be used and re-used by methods coming in a bit. Note the client handles ( e.g. self.takeoff_cli ) are stored as properties of the object, using self . This means thay can be accessed by other methods of the same object, again via self . Only publishers and service callers are included here. Subscribers are still left for the run() method as I don't want stuff to start running until later on. You could have kept these activities in other methods, creating new clients each time something needs to be published or called. However, they take work and delay due to interactions with the ROS ecosystem, so it's better to just get them done once at the start. Arguably, I should have put the wait_for_service calls in run() as well, so an object could be constructed in isolation from ROS if I wanted to. # on receiving status message, save it to global def state_callback(self,msg): self.last_state = msg self.get_logger().debug('Mode: {}. Armed: {}. System status: {}'.format(msg.mode,msg.armed,msg.system_status)) # on receiving positon message, save it to global def position_callback(self,msg): # determine altitude relative to start if self.init_alt: self.last_alt_rel = msg.altitude - self.init_alt self.last_pos = msg self.get_logger().debug('Drone at {}N,{}E altitude {}m'.format(msg.latitude, msg.longitude, self.last_alt_rel)) def wait_for_new_status(self): \"\"\" Wait for new state message to be received. These are sent at 1Hz so calling this is roughly equivalent to one second delay. \"\"\" if self.last_state: # if had a message before, wait for higher timestamp last_stamp = self.last_state.header.stamp.sec for try_wait in range(60): rclpy.spin_once(self) if self.last_state.header.stamp.sec > last_stamp: break else: # if never had a message, just wait for first one for try_wait in range(60): if self.last_state: break rclpy.spin_once(self) Callbacks and the wait_for_status() utility method are unchanged: these are already nice simple functions with clear, distinct purposes. def request_data_stream(self,msg_id,msg_interval): cmd_req = CommandLong.Request() cmd_req.command = 511 cmd_req.param1 = float(msg_id) cmd_req.param2 = float(msg_interval) future = self.cmd_cli.call_async(cmd_req) rclpy.spin_until_future_complete(self, future) # wait for response Above is the first of the new methods to take on a specific task: in the case, requesting a data stream. \"Make sure every module hides something\" is another good guideline . Here, we hide from later software that requesting data involves all this complicated stuff about long commands and service calls. The function takes the desired message msg_id and the message interval msg_interval as arguments so future calls can request different messages and rates. With the relevant service client already set up in the __init__ constructor, we can go straight ahead and call self.cmd_cli.call_async() without the set-up and waiting. def change_mode(self,new_mode): mode_req = SetMode.Request() mode_req.custom_mode = new_mode future = self.mode_cli.call_async(mode_req) rclpy.spin_until_future_complete(self, future) # wait for response Another helper method, change_mode does exactly what it says in the name, again hiding the associated ROS details under a simple Python call. For re-use, callers provide the new_mode as an argument. def arm_request(self): arm_req = CommandBool.Request() arm_req.value = True future = self.arm_cli.call_async(arm_req) rclpy.spin_until_future_complete(self, future) Hopefully the pattern is emerging: each of the steps of our control flow are now going to be single lines, calling the associated methods and hiding the ROS interfaces. arm_request doesn't need any arguments as it always does the same job. def takeoff(self,target_alt): takeoff_req = CommandTOL.Request() takeoff_req.altitude = target_alt future = self.takeoff_cli.call_async(takeoff_req) rclpy.spin_until_future_complete(self, future) def flyto(self,lat,lon,alt): self.last_target.pose.position.latitude = lat self.last_target.pose.position.longitude = lon self.last_target.pose.position.altitude = alt self.target_pub.publish(self.last_target) self.get_logger().info('Sent drone to {}N, {}E, altitude {}m'.format(lat,lon,alt)) Methods for take_off and flyto are hopefully self-explanatory, and show how Python code can just about comment itself if you choose the names clearly. Note that flyto() saves the commanded target to a property last_target for later use. I was trying to follow the Python style guide on function names so flyto really ought to be fly_to . I recommend you adopt a standard and stick to it. For all it can feel pedantic sometimes, it really does help when working on code as a group. def run(self): # set up two subscribers, one for vehicle state... state_sub = self.create_subscription(State, 'mavros/state', self.state_callback, 10) # ...and the other for global position pos_sub = self.create_subscription(NavSatFix, 'mavros/global_position/global', self.position_callback, 10) # first wait for the system status to become 3 \"standby\" # see https://mavlink.io/en/messages/common.html#MAV_STATE for try_standby in range(60): self.wait_for_new_status() if self.last_state.system_status==3: self.get_logger().info('Drone ready for flight') break The run() method starts off just as always, launching the subscriptions and waiting for the right status. # send command to request regular position updates self.request_data_stream(33, 1000000) self.get_logger().info('Requested position stream') # now change mode to GUIDED self.change_mode(\"GUIDED\") self.get_logger().info('Request sent for GUIDED mode.') Now the next two steps, asking for the position data and changing to GUIDED, are just two lines of code plus associated logging. It's much easier to follow the intent than before with the complexity of all the ROS moved to the methods. Why did I not put the get_logger().info() calls in the methods too? Don't know really - I did for flyto but not for the other methods. That inconsistency irks me now, but it made sense at the time. # next, try to arm the drone # keep trying until arming detected in state message, or 60 attempts for try_arm in range(60): self.arm_request() self.get_logger().info('Arming request sent.') self.wait_for_new_status() if self.last_state.armed: self.get_logger().info('Arming successful') # armed - grab init alt for relative working if self.last_pos: self.init_alt = self.last_pos.altitude break else: self.get_logger().error('Failed to arm') The arming step is slightly simpler with just the arm_request call doing the work. # take off and climb to 20.0m at current location self.takeoff(20.0) self.get_logger().info('Takeoff request sent.') Take off is now just one line calling the earlier method, plus a log record. # wait for drone to reach desired altitude, or 60 attempts for try_alt in range(60): self.wait_for_new_status() self.get_logger().info('Climbing, altitude {}m'.format(self.last_alt_rel)) if self.last_alt_rel > 19.0: self.get_logger().info('Close enough to flight altitude') break # move drone by sending setpoint message self.flyto(51.423, -2.671, self.init_alt - 30.0) # unexplained correction factor on altitude Moving the drone is again just a single line. # wait for drone to reach desired position, or timeout after 60 attempts for try_arrive in range(60): self.wait_for_new_status() d_lon = self.last_pos.longitude - self.last_target.pose.position.longitude d_lat = self.last_pos.latitude - self.last_target.pose.position.latitude self.get_logger().info('Target error {},{}'.format(d_lat,d_lon)) if abs(d_lon) < 0.0001: if abs(d_lat) < 0.0001: self.get_logger().info('Close enough to target delta={},{}'.format(d_lat,d_lon)) break Monitoring progress is largely unchanged, apart from using the stored last_target property to check distance. This actually feels clumsy compared to the rest of the code and I will ask you to improve upon it in the exercises. # return home and land self.change_mode(\"RTL\") self.get_logger().info('Request sent for RTL mode.') The change_mode method is used again to head home using RTL. # now just serve out the time until process killed while rclpy.ok(): rclpy.spin_once(self) def main(args=None): rclpy.init(args=args) controller_node = FenswoodDroneController() controller_node.run() if __name__ == '__main__': main() The remainder is unchanged. Back to tutorial contents","title":"Example code"},{"location":"tutorial/modular/#exercises","text":"All exercises involve editing the file fenswood_drone_controller/fenswood_drone_controller/controller_modular.py Create a method to move the camera. It should publish a message of type std_msgs/Float32 to the /vehicle_1/gimbal_tilt_cmd topic to move the camera, with 0 in the data field being horizontal and 1.57 being straight downwards. Add a method to measure distance (in some simple way) to the last target. Use it to simplify the code in the run() method. Then add a stage to your code that flies to a second target after the first has been reached. None of the methods in the example so far returned a value! If you include a return x statement in the method, you can use x = self.my_method(stuff) to access it. Use return a,b,c and a,b,c = self.my_method(stuff) to return multiple values , if that's required. Add a request for message 32, LOCAL_POSITION_NED . Observe what happens on foxglove looking at topic /vehicle_1/mavros/local_position/pose . In the code, add a subscriber to /vehicle_1/mavros/local_position/pose and try using this local altitude to track climb progress in run() . Back to tutorial contents","title":"Exercises"},{"location":"tutorial/old_school/","text":"Old-School Example \u00b6 Back to tutorial contents Introduction \u00b6 In this tutorial, a simple Python script will be used to control the drone, with the control flow managed just by the Python language flow. This approached is referred to as 'old school' in the minimal ROS2 examples and is not good programming style. However, it enables us to focus purely on the ROS interactions, stripped of any Python organization that may be unfamiliar to some readers. Therefore, the old school way seems the right place to start. Style matters. Good programming style makes code that is re-usable, maintainable, and likely to be correct. There are some celebrated lessons of style . It is also a hotly debated topic in Python, which offers many ways of doing every task, but some more Pythonic than others. Threads \u00b6 ROS uses a publish/subscribe model to exchange data between components using named topics . For example, for us to get the drone position, we learn from the documentation that MAVROS will publish it to a topic named /vehicle_1/mavros/global_position/global using the sensor_msgs/NavSatFix message type. Then we must subscribe to that topic to receive those messages. When we subscribe, we write a callback function that will run every time a position message is received and send its name when we subscribe. This is a very powerful and scalable way of sharing information but it means our program is multi-threaded: different parts of it will run at different times, potentially on top of each other. Python will handle most of the pain, like worrying what if a message changes halfway through us processing it. However, some ugliness remains: we will need to use global variables to allow the different threads to communicate with each other. In our example this will be really simple: the callbacks will just save the messages as they come in, and our code will just look at the last one saved. You will need to think about this more when you start working with the camera feed. You could just put a load of image processing code in a callback, but what happens if you get a new image in while you're still processing the last one? Our programme will have three threads: - the 'main' thread, executing the function main - the 'state' thread, executing the function state_callback whenever a state message is received - the position thread, executing the function position_callback whenever a positon message is received Example code \u00b6 To run this example: docker-compose -f docker-compose-old-school.yml up --build The key file is fenswood_drone_controller/fenswood_drone_controller/controller_old_school.py subdirectory. The remainder of this section describes how it works. import rclpy The library rclpy contains the core functionality for using ROS from Python. # import message definitions for receiving status and position from mavros_msgs.msg import State from sensor_msgs.msg import NavSatFix # import message definition for sending setpoint from geographic_msgs.msg import GeoPoseStamped # import service definitions for changing mode, arming, take-off and generic command from mavros_msgs.srv import SetMode, CommandBool, CommandTOL, CommandLong ROS communications are all typed, so to use any ROS channels requires importing the relevant information type as a Python class. There are two types of these definitions: messages from .msg libraries and services from .srv libraries: more on the distinction later. Each class is imported from the ROS package that defines it. For our example, we need: - the State message from the mavros_msgs package which will convey the readiness status from the drone - the NavSatFix message from the sensor_msgs package which will tell us the position from the drone - the GeoPoseStamped message from the geographic_msgs package which will take our position setpoint back to the drone - the services SetMode, CommandBool, CommandTOL, CommandLong from the mavros_msg package, which we will use to change modes, arm, take-off, and request data streams, respectively. g_node = None # global for the node handle g_last_state = None # global for last received status message g_last_pos = None # global for last received position message g_init_alt = None # global for global altitude at start g_last_alt_rel = None # global for last altitude relative to start Recalling the earlier discussion about threading these global variables will be used to store information from the callback functions for use in the main control thread (or, in the case of the g_node variable, vice versa ). Initial values of None means we can trap cases when no data has been received. Global variables are horrible things. You should really never use them as they can lead to all sorts of unexpected behaviour down the line - but they get us working quickly here. They will be replaced in the nery next tutorial. def state_callback(msg): global g_last_state g_last_state = msg g_node.get_logger().debug('Mode: {}. Armed: {}. System status: {}'.format(msg.mode,msg.armed,msg.system_status)) Above is our first callback function, which will run whenever we get a drone status message. The global line is needed before we can write to the global variable of that name, not just a local copy. Then all we do is save the incoming data in msg to the global and write a log entry. There are different grades of logging and debug() is the lowest, meaning we won't get a screen clogged with these messages unless we go and ask for them. We didn't need a global declaration for g_node because we're only reading from it. However, since the function writes to g_last_state , a global g_last_state is needed. It's a Python thing. def position_callback(msg): global g_last_pos, g_last_alt_rel # determine altitude relative to start if g_init_alt: g_last_alt_rel = msg.altitude - g_init_alt g_last_pos = msg g_node.get_logger().debug('Drone at {}N,{}E altitude {}m'.format(msg.latitude, msg.longitude, g_last_alt_rel)) Above is the other callback function, this time for the position message. The if g_init_alt: clause will only run if g_init_alt has been set to something other than its initial value of None . This means the g_last_alt_rel calculation only happens if g_init_alt has been set. This is part of a workaround to work with altitude relative to take-off position rather than the ambiguous absolute value, as discussed in the drone control tutorial . g_init_alt will be set later on when the drone is armed, after which the callback will also calculate the altitude relative to takeoff and store it in g_last_alt_rel . def wait_for_new_status(): \"\"\" Wait for new state message to be received. These are sent at 1Hz so calling this is roughly equivalent to one second delay. \"\"\" if g_last_state: # if had a message before, wait for higher timestamp last_stamp = g_last_state.header.stamp.sec for try_wait in range(60): rclpy.spin_once(g_node) if g_last_state.header.stamp.sec > last_stamp: break else: # if never had a message, just wait for first one for try_wait in range(60): if g_last_state: break rclpy.spin_once(g_node) Our simulation runs in real time and the controller will sometimes need to wait for things to happen. Sadly we can't just use time.sleep(1) from the time Python library: this doesn't play nicely with ROS threads and ends up blocking all the callbacks as well. Instead, we must use ROS spin methods to give up the time to the other threads. Since we do this several times in the script, the function wait_for_new_status brings it all together. The if g_last_state: line breaks it into two clauses. If true, this means we have received a status message before. The function grabs the seconds value of the timestamp of the last message in the variable last_stamp . Then the for loop runs until a new message with a later timestamp has been received. The spin_once() command waits until one of the other threads has done some work. If we had never received a message before, the first if g_last_state: fails, and instead we just keep spinning until any message has been received. In testing, the state messages come in at 1Hz, so this function waits for about 1s. Be careful relying on that though: if a ground station were to request state messages at a different rate, that delay time could change. I could have done this with a while loop, but the for loop is better practice for real world control, as it means the program cannot hang forever and will eventually time out. However, I have failed to handle this timeout (or any of the others in the example) properly: the programme will just carry on. Python provides a lovely else syntax (see documentation ) that would handle this very elegantly. def main(args=None): global g_node, g_init_alt The main function will carry the main thread of our program, including all the decision-making in this example. The global line means we will be writing to a couple of variables, as discussed already. rclpy.init(args=args) g_node = rclpy.create_node('example_controller') The above are two bits of ROS 'magic'. Every process that talks over ROS is called a 'node' and has to register itself with the rest of the ROS environment and give itself a name. You will see this name turn up in the logs on Foxglove to identify which message comes from which node. state_sub = g_node.create_subscription(State, '/vehicle_1/mavros/state', state_callback, 10) pos_sub = g_node.create_subscription(NavSatFix, '/vehicle_1/mavros/global_position/global', position_callback, 10) This sets up our subscribers, specifying the message types, topic names, and callback functions for each. Don't worry about the 10 for now. These lines create the two additional threads besides the main one, and once they've been executed, callbacks can start running. Now the script just works through the steps described in the Drone control tutorial for try_standby in range(60): wait_for_new_status() if g_last_state.system_status==3: g_node.get_logger().info('Drone ready for flight') break First, above, we wait up to a minute (assuming wait_for_new_status takes one second) to reach the 'standby' status (3). If we reach one minute and standby hasn't been reached, the code just moves on anyway. # send command to request regular position updates cmd_req = CommandLong.Request() cmd_req.command = 511 cmd_req.param1 = float(33) # msg ID for position is 33 \\ # https://mavlink.io/en/messages/common.html#GLOBAL_POSITION_INT cmd_req.param2 = float(1000000) # 1000000 micro-second interval : 1Hz rate The next step is to request the position data. MAVROS doesn't give us a direct route to do this, but it does provide a ROS service for us to send any MAVLINK message of our choice. The code above compiles a service request of type mavros_msgs/CommandLong to perform the request. Following these instructions , we send a MAVLINK SET_MESSAGE_INTERVAL message, number 511 using param1 to identify the message we want, number 33, GLOBAL_POSITION_INT and param2 to set the interval in microseconds. MAVROS will get upset if the param values are not float variables, hence the conversions. cmd_cli = g_node.create_client(CommandLong, '/vehicle_1/mavros/cmd/command') while not cmd_cli.wait_for_service(timeout_sec=1.0): g_node.get_logger().info('command_int service not available, waiting again...') future = cmd_cli.call_async(cmd_req) rclpy.spin_until_future_complete(g_node, future) # wait for response g_node.get_logger().info('Requested position stream') Services are another way of communicating in ROS , an alternative to topic publishing and subscribing. Services are to topics what phone calls are to text messages. A service is called by a client and a server then responds . In our case, we learn from the documentation that MAVROS provides the function we need as a service named \\vehicle_1\\mavros\\cmd\\command with defined message type mavros_msgs/CommandLong . Having constructed our CommandLong in the previous code chunk, we start here by creating a 'client' for calling the service named cmd_cli and then wait to make sure the corresponding server is ready using while not cmd_cli.wait_for_service() . As services have the risk of delaying or even deadlocking your code, ROS gives some rather complicated mechanisms for calling them. The call_async() command starts (yet) another thread to wait for the response, and all I do is use spin_until_future_complete() to just wait for the response and then log that it finished. The response data would be in the future object after the spin is done. Lazily, I just ignore it, assume it worked, and move on. Generally, I am not a fan of ROS services. ROS2 has had to make them rather complicated to overcome the problems of deadlocks, when nodes end up waiting for each other to respond to services. I can see the advantage of having explicit responses to some messages, but the associated complexity is a pain. The old Parrot ARDrone ROS drivers managed to do absolutely everything with just a few topics and no services. Meanwhile, the newer ROS actions provide a much better interface for call-and-response behaviour. Lots of really useful tools like py_trees_ros support topics and actions but not services. Still, we are lucky that others have produced MAVROS for us, so it's worth a little pain to accommodate their choices. mode_req = SetMode.Request() mode_req.custom_mode = \"GUIDED\" mode_cli = g_node.create_client(SetMode, '/vehicle_1/mavros/set_mode') while not mode_cli.wait_for_service(timeout_sec=1.0): g_node.get_logger().info('set_mode service not available, waiting again...') future = mode_cli.call_async(mode_req) rclpy.spin_until_future_complete(g_node, future) # wait for response g_node.get_logger().info('Request sent for GUIDED mode.') Changing mode requires another service call. Hopefully the pattern is emerging: build a service request mode_req , then a client mode_cli , wait for the service, call it, spin_until_future_complete to wait for completion, and then move on. None of the service calls in this tutorial ever check the response. If necessary, I you could verify the mode change by looking at the state message. arm_req = CommandBool.Request() arm_req.value = True arm_cli = g_node.create_client(CommandBool, '/vehicle_1/mavros/cmd/arming') while not arm_cli.wait_for_service(timeout_sec=1.0): g_node.get_logger().info('arming service not available, waiting again...') # keep trying until arming detected in state message, or 60 attempts for try_arm in range(60): future = arm_cli.call_async(arm_req) rclpy.spin_until_future_complete(g_node, future) g_node.get_logger().info('Arming request sent.') wait_for_new_status() if g_last_state.armed: g_node.get_logger().info('Arming successful') # armed - grab init alt for relative working if g_last_pos: g_init_alt = g_last_pos.altitude break else: g_node.get_logger().error('Failed to arm') Arming the drone is done by calling yet another service. Again it begins by constructing the arm_req request and the arm_cli client. However, since we anticipate arming to fail while the GPS etc is still warming up, the code here repeats for up to 60 attempts, calling the service using call_async , doing a spin_until_future_complete until the service completes, waiting for a new status message, and only stopping via break if that status shows armed to be True . If arming succeeds, the code also grabs the current altitude in g_init_alt to enable relative altitude calculation. The else: clause will only run if the for loop makes it to its full 60 interations without terminating via a break. It therefore handles the case where arming times out, sending an error message to the log. takeoff_req = CommandTOL.Request() takeoff_req.altitude = 20.0 takeoff_cli = g_node.create_client(CommandTOL, '/vehicle_1/mavros/cmd/takeoff') while not takeoff_cli.wait_for_service(timeout_sec=1.0): g_node.get_logger().info('takeoff service not available, waiting again...') future = takeoff_cli.call_async(takeoff_req) rclpy.spin_until_future_complete(g_node, future) g_node.get_logger().info('Takeoff request sent.') Take-off is achieved by yet another service call following a hopefully familiar pattern. This time the request includes the altitude to which the drone should climb, which in this circumstance is always interpreted relative to ground level. # wait for drone to reach desired altitude, or 600 attempts for try_alt in range(600): wait_for_new_status() g_node.get_logger().info('Climbing, altitude {}m'.format(g_last_alt_rel)) if g_last_alt_rel > 19.0: g_node.get_logger().info('Close enough to flight altitude') break The above snippet waits for 600 seconds or for the drone to reach 19m above its arming altitude. Note the g_last_alt_rel variable will be calculated in the state_callback function (in its own thread) as the g_init_alt variable has been set in the main thread. # move drone by sending setpoint message target_msg = GeoPoseStamped() target_msg.pose.position.latitude = 51.423 target_msg.pose.position.longitude = -2.671 target_msg.pose.position.altitude = g_init_alt + 20.0 - 50.0 # MSL/ellipsoid correction Time to get the drone moving. Start by composing a GeoPoseStamped() message with a target location. The correction factor -50.0 accounts for the differences between different altitude definitions - it's something of a hack but seems to work OK for this short move. target_pub = g_node.create_publisher(GeoPoseStamped, '/vehicle_1/mavros/setpoint_position/global', 10) wait_for_new_status() # short delay after creating publisher ensures message not lost target_pub.publish(target_msg) g_node.get_logger().info('Sent drone to {}N, {}E, altitude {}m'.format(target_msg.pose.position.latitude, target_msg.pose.position.longitude, target_msg.pose.position.altitude)) And publishing is as simple as this - create a publisher object and then call its publish method to send the message. Note the wait_for_new_status() call between creating the publisher and using it - I've found that using publishers seem to take a little time to get ready, and if you try and publish straight after creating, the message often vanishes. # wait for drone to reach desired position, or timeout after 600 attempts for try_arrive in range(600): wait_for_new_status() d_lon = g_last_pos.longitude - target_msg.pose.position.longitude d_lat = g_last_pos.latitude - target_msg.pose.position.latitude g_node.get_logger().info('Target error {},{}'.format(d_lat,d_lon)) if abs(d_lon) < 0.0001: if abs(d_lat) < 0.0001: g_node.get_logger().info('Close enough to target delta={},{}'.format(d_lat,d_lon)) break The drone should now be moving. The position callbacks will be running in their own thread, so I can just access the last received message in the g_last_pos global. When both numbers match to four decimal places (or on timeout after 600 seconds) I declare the target reached and allow the code to move on. mode_req.custom_mode = \"RTL\" future = mode_cli.call_async(mode_req) rclpy.spin_until_future_complete(g_node, future) # wait for response g_node.get_logger().info('Request sent for RTL mode.') The final step is to send the drone back home. The mode request mode_req and mode client mode_cli are already set up from earlier, and the set_mode service has already been proven available with an earlier wait_for_service() so there's no need for another. I just change the desired mode in mode_req , call the service again and do another spin_until_future_complete to let it finish. # now just serve out the time until process killed while rclpy.ok(): rclpy.spin_once(g_node) The control task is complete now. I ought to monitor the drone's progress until it lands and exit the program cleanly. Lazily, I just keep executing spin_once() to keep the callbacks running until rclpy.ok() fails, which happens when the application is killed with a Ctrl-C . if __name__ == '__main__': main() This last bit above is another 'Python thing'. It detects the special case where the script is executed as a program (instead of just imported as a module) and directs execution to the main() function. I'm not even sure it's needed with ROS2 but it's habit. Exercises \u00b6 Change where the drone flies, perhaps trying some of the locations provided in the project briefing document. Add a second location, so the drone flies to the first location and then on to a second. Add a request for message 32, LOCAL_POSITION_NED to be sent. Observe what happens on foxglove looking at topic /vehicle_1/mavros/local_position/pose . In the code, add a subscriber to /vehicle_1/mavros/local_position/pose and print the local information to the log. Instead of sending the drone back to the starting location, trying using Land mode to land it at the target location. Add a final stage to the program that checks the drone makes it back to the ground, exits gracefully if it does, or logs an error if it takes too long.","title":"3. An Old-School Example"},{"location":"tutorial/old_school/#old-school-example","text":"Back to tutorial contents","title":"Old-School Example"},{"location":"tutorial/old_school/#introduction","text":"In this tutorial, a simple Python script will be used to control the drone, with the control flow managed just by the Python language flow. This approached is referred to as 'old school' in the minimal ROS2 examples and is not good programming style. However, it enables us to focus purely on the ROS interactions, stripped of any Python organization that may be unfamiliar to some readers. Therefore, the old school way seems the right place to start. Style matters. Good programming style makes code that is re-usable, maintainable, and likely to be correct. There are some celebrated lessons of style . It is also a hotly debated topic in Python, which offers many ways of doing every task, but some more Pythonic than others.","title":"Introduction"},{"location":"tutorial/old_school/#threads","text":"ROS uses a publish/subscribe model to exchange data between components using named topics . For example, for us to get the drone position, we learn from the documentation that MAVROS will publish it to a topic named /vehicle_1/mavros/global_position/global using the sensor_msgs/NavSatFix message type. Then we must subscribe to that topic to receive those messages. When we subscribe, we write a callback function that will run every time a position message is received and send its name when we subscribe. This is a very powerful and scalable way of sharing information but it means our program is multi-threaded: different parts of it will run at different times, potentially on top of each other. Python will handle most of the pain, like worrying what if a message changes halfway through us processing it. However, some ugliness remains: we will need to use global variables to allow the different threads to communicate with each other. In our example this will be really simple: the callbacks will just save the messages as they come in, and our code will just look at the last one saved. You will need to think about this more when you start working with the camera feed. You could just put a load of image processing code in a callback, but what happens if you get a new image in while you're still processing the last one? Our programme will have three threads: - the 'main' thread, executing the function main - the 'state' thread, executing the function state_callback whenever a state message is received - the position thread, executing the function position_callback whenever a positon message is received","title":"Threads"},{"location":"tutorial/old_school/#example-code","text":"To run this example: docker-compose -f docker-compose-old-school.yml up --build The key file is fenswood_drone_controller/fenswood_drone_controller/controller_old_school.py subdirectory. The remainder of this section describes how it works. import rclpy The library rclpy contains the core functionality for using ROS from Python. # import message definitions for receiving status and position from mavros_msgs.msg import State from sensor_msgs.msg import NavSatFix # import message definition for sending setpoint from geographic_msgs.msg import GeoPoseStamped # import service definitions for changing mode, arming, take-off and generic command from mavros_msgs.srv import SetMode, CommandBool, CommandTOL, CommandLong ROS communications are all typed, so to use any ROS channels requires importing the relevant information type as a Python class. There are two types of these definitions: messages from .msg libraries and services from .srv libraries: more on the distinction later. Each class is imported from the ROS package that defines it. For our example, we need: - the State message from the mavros_msgs package which will convey the readiness status from the drone - the NavSatFix message from the sensor_msgs package which will tell us the position from the drone - the GeoPoseStamped message from the geographic_msgs package which will take our position setpoint back to the drone - the services SetMode, CommandBool, CommandTOL, CommandLong from the mavros_msg package, which we will use to change modes, arm, take-off, and request data streams, respectively. g_node = None # global for the node handle g_last_state = None # global for last received status message g_last_pos = None # global for last received position message g_init_alt = None # global for global altitude at start g_last_alt_rel = None # global for last altitude relative to start Recalling the earlier discussion about threading these global variables will be used to store information from the callback functions for use in the main control thread (or, in the case of the g_node variable, vice versa ). Initial values of None means we can trap cases when no data has been received. Global variables are horrible things. You should really never use them as they can lead to all sorts of unexpected behaviour down the line - but they get us working quickly here. They will be replaced in the nery next tutorial. def state_callback(msg): global g_last_state g_last_state = msg g_node.get_logger().debug('Mode: {}. Armed: {}. System status: {}'.format(msg.mode,msg.armed,msg.system_status)) Above is our first callback function, which will run whenever we get a drone status message. The global line is needed before we can write to the global variable of that name, not just a local copy. Then all we do is save the incoming data in msg to the global and write a log entry. There are different grades of logging and debug() is the lowest, meaning we won't get a screen clogged with these messages unless we go and ask for them. We didn't need a global declaration for g_node because we're only reading from it. However, since the function writes to g_last_state , a global g_last_state is needed. It's a Python thing. def position_callback(msg): global g_last_pos, g_last_alt_rel # determine altitude relative to start if g_init_alt: g_last_alt_rel = msg.altitude - g_init_alt g_last_pos = msg g_node.get_logger().debug('Drone at {}N,{}E altitude {}m'.format(msg.latitude, msg.longitude, g_last_alt_rel)) Above is the other callback function, this time for the position message. The if g_init_alt: clause will only run if g_init_alt has been set to something other than its initial value of None . This means the g_last_alt_rel calculation only happens if g_init_alt has been set. This is part of a workaround to work with altitude relative to take-off position rather than the ambiguous absolute value, as discussed in the drone control tutorial . g_init_alt will be set later on when the drone is armed, after which the callback will also calculate the altitude relative to takeoff and store it in g_last_alt_rel . def wait_for_new_status(): \"\"\" Wait for new state message to be received. These are sent at 1Hz so calling this is roughly equivalent to one second delay. \"\"\" if g_last_state: # if had a message before, wait for higher timestamp last_stamp = g_last_state.header.stamp.sec for try_wait in range(60): rclpy.spin_once(g_node) if g_last_state.header.stamp.sec > last_stamp: break else: # if never had a message, just wait for first one for try_wait in range(60): if g_last_state: break rclpy.spin_once(g_node) Our simulation runs in real time and the controller will sometimes need to wait for things to happen. Sadly we can't just use time.sleep(1) from the time Python library: this doesn't play nicely with ROS threads and ends up blocking all the callbacks as well. Instead, we must use ROS spin methods to give up the time to the other threads. Since we do this several times in the script, the function wait_for_new_status brings it all together. The if g_last_state: line breaks it into two clauses. If true, this means we have received a status message before. The function grabs the seconds value of the timestamp of the last message in the variable last_stamp . Then the for loop runs until a new message with a later timestamp has been received. The spin_once() command waits until one of the other threads has done some work. If we had never received a message before, the first if g_last_state: fails, and instead we just keep spinning until any message has been received. In testing, the state messages come in at 1Hz, so this function waits for about 1s. Be careful relying on that though: if a ground station were to request state messages at a different rate, that delay time could change. I could have done this with a while loop, but the for loop is better practice for real world control, as it means the program cannot hang forever and will eventually time out. However, I have failed to handle this timeout (or any of the others in the example) properly: the programme will just carry on. Python provides a lovely else syntax (see documentation ) that would handle this very elegantly. def main(args=None): global g_node, g_init_alt The main function will carry the main thread of our program, including all the decision-making in this example. The global line means we will be writing to a couple of variables, as discussed already. rclpy.init(args=args) g_node = rclpy.create_node('example_controller') The above are two bits of ROS 'magic'. Every process that talks over ROS is called a 'node' and has to register itself with the rest of the ROS environment and give itself a name. You will see this name turn up in the logs on Foxglove to identify which message comes from which node. state_sub = g_node.create_subscription(State, '/vehicle_1/mavros/state', state_callback, 10) pos_sub = g_node.create_subscription(NavSatFix, '/vehicle_1/mavros/global_position/global', position_callback, 10) This sets up our subscribers, specifying the message types, topic names, and callback functions for each. Don't worry about the 10 for now. These lines create the two additional threads besides the main one, and once they've been executed, callbacks can start running. Now the script just works through the steps described in the Drone control tutorial for try_standby in range(60): wait_for_new_status() if g_last_state.system_status==3: g_node.get_logger().info('Drone ready for flight') break First, above, we wait up to a minute (assuming wait_for_new_status takes one second) to reach the 'standby' status (3). If we reach one minute and standby hasn't been reached, the code just moves on anyway. # send command to request regular position updates cmd_req = CommandLong.Request() cmd_req.command = 511 cmd_req.param1 = float(33) # msg ID for position is 33 \\ # https://mavlink.io/en/messages/common.html#GLOBAL_POSITION_INT cmd_req.param2 = float(1000000) # 1000000 micro-second interval : 1Hz rate The next step is to request the position data. MAVROS doesn't give us a direct route to do this, but it does provide a ROS service for us to send any MAVLINK message of our choice. The code above compiles a service request of type mavros_msgs/CommandLong to perform the request. Following these instructions , we send a MAVLINK SET_MESSAGE_INTERVAL message, number 511 using param1 to identify the message we want, number 33, GLOBAL_POSITION_INT and param2 to set the interval in microseconds. MAVROS will get upset if the param values are not float variables, hence the conversions. cmd_cli = g_node.create_client(CommandLong, '/vehicle_1/mavros/cmd/command') while not cmd_cli.wait_for_service(timeout_sec=1.0): g_node.get_logger().info('command_int service not available, waiting again...') future = cmd_cli.call_async(cmd_req) rclpy.spin_until_future_complete(g_node, future) # wait for response g_node.get_logger().info('Requested position stream') Services are another way of communicating in ROS , an alternative to topic publishing and subscribing. Services are to topics what phone calls are to text messages. A service is called by a client and a server then responds . In our case, we learn from the documentation that MAVROS provides the function we need as a service named \\vehicle_1\\mavros\\cmd\\command with defined message type mavros_msgs/CommandLong . Having constructed our CommandLong in the previous code chunk, we start here by creating a 'client' for calling the service named cmd_cli and then wait to make sure the corresponding server is ready using while not cmd_cli.wait_for_service() . As services have the risk of delaying or even deadlocking your code, ROS gives some rather complicated mechanisms for calling them. The call_async() command starts (yet) another thread to wait for the response, and all I do is use spin_until_future_complete() to just wait for the response and then log that it finished. The response data would be in the future object after the spin is done. Lazily, I just ignore it, assume it worked, and move on. Generally, I am not a fan of ROS services. ROS2 has had to make them rather complicated to overcome the problems of deadlocks, when nodes end up waiting for each other to respond to services. I can see the advantage of having explicit responses to some messages, but the associated complexity is a pain. The old Parrot ARDrone ROS drivers managed to do absolutely everything with just a few topics and no services. Meanwhile, the newer ROS actions provide a much better interface for call-and-response behaviour. Lots of really useful tools like py_trees_ros support topics and actions but not services. Still, we are lucky that others have produced MAVROS for us, so it's worth a little pain to accommodate their choices. mode_req = SetMode.Request() mode_req.custom_mode = \"GUIDED\" mode_cli = g_node.create_client(SetMode, '/vehicle_1/mavros/set_mode') while not mode_cli.wait_for_service(timeout_sec=1.0): g_node.get_logger().info('set_mode service not available, waiting again...') future = mode_cli.call_async(mode_req) rclpy.spin_until_future_complete(g_node, future) # wait for response g_node.get_logger().info('Request sent for GUIDED mode.') Changing mode requires another service call. Hopefully the pattern is emerging: build a service request mode_req , then a client mode_cli , wait for the service, call it, spin_until_future_complete to wait for completion, and then move on. None of the service calls in this tutorial ever check the response. If necessary, I you could verify the mode change by looking at the state message. arm_req = CommandBool.Request() arm_req.value = True arm_cli = g_node.create_client(CommandBool, '/vehicle_1/mavros/cmd/arming') while not arm_cli.wait_for_service(timeout_sec=1.0): g_node.get_logger().info('arming service not available, waiting again...') # keep trying until arming detected in state message, or 60 attempts for try_arm in range(60): future = arm_cli.call_async(arm_req) rclpy.spin_until_future_complete(g_node, future) g_node.get_logger().info('Arming request sent.') wait_for_new_status() if g_last_state.armed: g_node.get_logger().info('Arming successful') # armed - grab init alt for relative working if g_last_pos: g_init_alt = g_last_pos.altitude break else: g_node.get_logger().error('Failed to arm') Arming the drone is done by calling yet another service. Again it begins by constructing the arm_req request and the arm_cli client. However, since we anticipate arming to fail while the GPS etc is still warming up, the code here repeats for up to 60 attempts, calling the service using call_async , doing a spin_until_future_complete until the service completes, waiting for a new status message, and only stopping via break if that status shows armed to be True . If arming succeeds, the code also grabs the current altitude in g_init_alt to enable relative altitude calculation. The else: clause will only run if the for loop makes it to its full 60 interations without terminating via a break. It therefore handles the case where arming times out, sending an error message to the log. takeoff_req = CommandTOL.Request() takeoff_req.altitude = 20.0 takeoff_cli = g_node.create_client(CommandTOL, '/vehicle_1/mavros/cmd/takeoff') while not takeoff_cli.wait_for_service(timeout_sec=1.0): g_node.get_logger().info('takeoff service not available, waiting again...') future = takeoff_cli.call_async(takeoff_req) rclpy.spin_until_future_complete(g_node, future) g_node.get_logger().info('Takeoff request sent.') Take-off is achieved by yet another service call following a hopefully familiar pattern. This time the request includes the altitude to which the drone should climb, which in this circumstance is always interpreted relative to ground level. # wait for drone to reach desired altitude, or 600 attempts for try_alt in range(600): wait_for_new_status() g_node.get_logger().info('Climbing, altitude {}m'.format(g_last_alt_rel)) if g_last_alt_rel > 19.0: g_node.get_logger().info('Close enough to flight altitude') break The above snippet waits for 600 seconds or for the drone to reach 19m above its arming altitude. Note the g_last_alt_rel variable will be calculated in the state_callback function (in its own thread) as the g_init_alt variable has been set in the main thread. # move drone by sending setpoint message target_msg = GeoPoseStamped() target_msg.pose.position.latitude = 51.423 target_msg.pose.position.longitude = -2.671 target_msg.pose.position.altitude = g_init_alt + 20.0 - 50.0 # MSL/ellipsoid correction Time to get the drone moving. Start by composing a GeoPoseStamped() message with a target location. The correction factor -50.0 accounts for the differences between different altitude definitions - it's something of a hack but seems to work OK for this short move. target_pub = g_node.create_publisher(GeoPoseStamped, '/vehicle_1/mavros/setpoint_position/global', 10) wait_for_new_status() # short delay after creating publisher ensures message not lost target_pub.publish(target_msg) g_node.get_logger().info('Sent drone to {}N, {}E, altitude {}m'.format(target_msg.pose.position.latitude, target_msg.pose.position.longitude, target_msg.pose.position.altitude)) And publishing is as simple as this - create a publisher object and then call its publish method to send the message. Note the wait_for_new_status() call between creating the publisher and using it - I've found that using publishers seem to take a little time to get ready, and if you try and publish straight after creating, the message often vanishes. # wait for drone to reach desired position, or timeout after 600 attempts for try_arrive in range(600): wait_for_new_status() d_lon = g_last_pos.longitude - target_msg.pose.position.longitude d_lat = g_last_pos.latitude - target_msg.pose.position.latitude g_node.get_logger().info('Target error {},{}'.format(d_lat,d_lon)) if abs(d_lon) < 0.0001: if abs(d_lat) < 0.0001: g_node.get_logger().info('Close enough to target delta={},{}'.format(d_lat,d_lon)) break The drone should now be moving. The position callbacks will be running in their own thread, so I can just access the last received message in the g_last_pos global. When both numbers match to four decimal places (or on timeout after 600 seconds) I declare the target reached and allow the code to move on. mode_req.custom_mode = \"RTL\" future = mode_cli.call_async(mode_req) rclpy.spin_until_future_complete(g_node, future) # wait for response g_node.get_logger().info('Request sent for RTL mode.') The final step is to send the drone back home. The mode request mode_req and mode client mode_cli are already set up from earlier, and the set_mode service has already been proven available with an earlier wait_for_service() so there's no need for another. I just change the desired mode in mode_req , call the service again and do another spin_until_future_complete to let it finish. # now just serve out the time until process killed while rclpy.ok(): rclpy.spin_once(g_node) The control task is complete now. I ought to monitor the drone's progress until it lands and exit the program cleanly. Lazily, I just keep executing spin_once() to keep the callbacks running until rclpy.ok() fails, which happens when the application is killed with a Ctrl-C . if __name__ == '__main__': main() This last bit above is another 'Python thing'. It detects the special case where the script is executed as a program (instead of just imported as a module) and directs execution to the main() function. I'm not even sure it's needed with ROS2 but it's habit.","title":"Example code"},{"location":"tutorial/old_school/#exercises","text":"Change where the drone flies, perhaps trying some of the locations provided in the project briefing document. Add a second location, so the drone flies to the first location and then on to a second. Add a request for message 32, LOCAL_POSITION_NED to be sent. Observe what happens on foxglove looking at topic /vehicle_1/mavros/local_position/pose . In the code, add a subscriber to /vehicle_1/mavros/local_position/pose and print the local information to the log. Instead of sending the drone back to the starting location, trying using Land mode to land it at the target location. Add a final stage to the program that checks the drone makes it back to the ground, exits gracefully if it does, or logs an error if it takes too long.","title":"Exercises"},{"location":"tutorial/perception/","text":"Adding perception \u00b6 Back to tutorial contents Introduction \u00b6 All the other examples in this tutorial focus on controlling the drone. However, you may decide to close the loop on the control problem using some image processing on the camera feed from the drone. This tutorial gives you a framework for doing so using the OpenCV image processing framework. In doing so, you will also learn how to extend the simulation application to: - install third-party libraries and ROS packages, in this case OpenCV and the associated vision_opencv ROS package; and - compile and launch multiple ROS nodes within a modular control system. OpenCV is a free open-source image processing library. It offers a variety of tools for analyzing and manipulating images, nicely wrapped in a nice Python interface, with good tutorials . OpenCV is not part of ROS, but others have done the work to provide a simple 'bridge' for converting ROS image messages to OpenCV and back. There are also various extra tutorials available online, including this one which I relied on to develop this tutorial. OpenCV is not the latest all-singing-all-dancing deep learning vision solution - but it is easy to learn and probably enough for finding big red blobs in a green world. Other tutorials have emphasized the importance of modularity and the same applies here. Each module should do one thing well. Our controller.py script provides a nice, coherent set of drone control capability but it's already getting long. It would be cluttered to try and squeeze image processing into it as well, so this example will put the image processing in another file to be run as another ROS node. Some kind of interface will need to be worked out to share information from the perception node to the controller node - but ROS makes that kind of communication easy. Keeping the two separate also helps development: one team member can work on control while another works on perception, without creating conflicts. Software deployment \u00b6 The tutorial so far has deliberately hidden a lot of the Starling framework around the controller. You have seen and worked on just the one file controller.py and we have provided some 'magic' that runs that script and a simulator, hooked up together, when you type in that docker-compose... command. Since all we have been changing is the one file, none of the rest of the framework has changed, and that --build bit on the end of the docker-compose... command has made sure to pick up the edited file each time. So far so good, but now we are extending the framework, it is time to look further into the 'magic'. It is covered in depth in the Starling overview chapter of the advanced tutorial but briefly, we will deploy the application shown below: The steps to get perception working are: write the Python code for the image processing tell our fenswood_drone_controller ROS package where to find it extend the launch file so the image processor is started along with the controller make sure the Docker container for the controller has the necessary dependencies installed If you do the advanced tutorial, you will learn a bit more about how all of this works together and how you might be able to do some more complex things! Back to tutorial contents Example code \u00b6 To run this example, use docker-compose up --build as before or run the one in the 6_perception directory. The remainder of this section works through each of the steps identified above, corresponding to a particular file. Writing the image processing code \u00b6 A separate file fenswood_drone_controller/fenswood_drone_controller/image_processor.py contained the Python code for doing the image processing, such as it is. Why the repeated name? It happens a lot in Python. The outer directory is the ROS package and the inner one is the Python package. You do need both. import rclpy from rclpy.node import Node from sensor_msgs.msg import Image import cv2 from cv_bridge import CvBridge The first two imports of rclpy and Node are standard ROS stuff and the same as for the controller, as we will be developing a class for our own ROS node. The Image class is the standard ROS message type for sharing images. (Happily for those of us who don't know a MOV from an MPEG, ROS hides all the practical pain of image transport from us.) The cv2 library is the entire OpenCV toolset. Finally CvBridge is the thing that converts a ROS image message to an OpenCV image object, or vice versa . class ImageProcessor(Node): def __init__(self): super().__init__('image_processor') self.br = CvBridge() As for the controller, a new class is defined as a child of the Node class to represent the image processing node. It calls the parent constructor to get ROS set up. The only other thing it does it create a CvBridge for later use doing the conversions. def start(self): # set up subscriber for image state_sub = self.create_subscription(Image, 'camera/image_raw', self.image_callback, 10) The start method will set the node actually working by subscribing to the image topic and running the callback on each response. This node is completely callback-driven so there is nothing else to do here. Note: it's usually a bad idea to do lots of work in callbacks, especially on something quite high-rate like a camera feed. In the exercises, I will ask you to improve upon this. # on receiving image, convert and log information def image_callback(self,msg): img = self.br.imgmsg_to_cv2(msg) # can do OpenCV stuff on img now shp = img.shape # just get the size self.get_logger().info('Got an image of {} x {}'.format(shp[0],shp[1])) The image callback method does very little for now, but enough to see if everything is working. The CvBridge created in __init__ is used to convert the image message to an OpenCV image object. All I do is extract its size using the shape property and log it. def main(args=None): rclpy.init(args=args) image_node = ImageProcessor() image_node.start() rclpy.spin(image_node) if __name__ == '__main__': main() The rest of the file is almost identical to the controller case. The main function creates the node object, starts the subscription, and then uses spin to hand over timing to ROS. The if __name__ ... bit is here out of habit. Telling ROS where to find it \u00b6 The setup.py file in the upper fenswood_drone_controller directory tells ROS where to find the bits of Python it might need, including scripts we want to run. It's a clumsy set-up but happily we'll only need to edit part... from setuptools import setup from glob import glob package_name = \"fenswood_drone_controller\" setup( name=package_name, version=\"0.0.0\", packages=[package_name], data_files=[ (\"share/ament_index/resource_index/packages\",[\"resource/\"+package_name]), (\"share/\" + package_name, ['package.xml']), (\"share/\" + package_name, glob('launch/*.launch.*')) ], install_requires=[\"setuptools\"], zip_safe=True, maintainer=\"Robert Clarke\", maintainer_email=\"TODO\", description=\"Example Python controller for Ardupilot at Fenswood\", license=\"TODO\", tests_require=[\"pytest\"], entry_points={ \"console_scripts\": [ \"controller = fenswood_drone_controller.controller:main\", \"controller_old_school = fenswood_drone_controller.controller_old_school:main\", \"controller_simple_class = fenswood_drone_controller.controller_simple_class:main\", \"controller_modular = fenswood_drone_controller.controller_modular:main\", \"controller_finite_state = fenswood_drone_controller.controller_finite_state:main\", \"image_processor = fenswood_drone_controller.image_processor:main\" ] } ) There, that bit right at the end: added to the console_scripts list entry in the entry_points dictionary, the item \"image_processor = fenswood_drone_controller.image_processor:main\" tells ROS that you run an image_processor node by calling the main function in the image_processor module of the fenswood_drone_controller package. Please don't ask the general principles behind this - unless you want to get really into Python and ROS packaging, just follow the pattern. Telling ROS to run it \u00b6 Most ROS applications quickly encounter the need to run multiple collaborating nodes. ROS supports various types of launch file to support running complex combinations of things, perhaps with different configurations, using a single command. You can even write launch files in Python to do clever conditional stuff, but I prefer the basic XML version for a simple job like ours. The (updated) launch file is controller.launch.xml living in the launch subdirectory of the fenswood_drone_controller package directory. Other files are configured to tell ROS where it lives and to tell Docker to run it on starting our container, so we just need to add the perception node to it. <launch> <node pkg=\"fenswood_drone_controller\" exec=\"controller\" /> <node pkg=\"fenswood_drone_controller\" exec=\"image_processor\" /> </launch> It's pretty simple: the whole XML file contains a big <launch> element to which we have added a second <node> subelement asking ROS to run the image_processor node (same name we used in setup.py ) from the fenswood_drone_controller package. Installing the dependecies on the Docker container \u00b6 Recall that the simulation application is a series of Docker containers running together, like little simulated computers networked together. While four of the five containers involved are pulled pre-built from the cloud, the controller container that runs the controller and image processor is built locally. (That's what the --build thing is about.) The recipe for this container is contained in the Dockerfile in the fenswood_drone_controller directory . Noting that each controller is like its own computer, we need to ensure that computer has OpenCV installed to run our mage processor code. This means editing the Dockerfile as shown below. FROM uobflightlabstarling/starling-controller-base:latest This is the starting point: Starling provides a base recipe (formally an image ) for controller development, which this file will then modify. RUN apt update RUN apt-get install -y ros-foxy-vision-opencv python3-pip RUN pip3 install opencv-python These are the new lines, and they're just like the commands you would type into your Linux computer if you wanted to do this locally. First update the software list, then install the vision_opencv package for ROS2 version foxy . Also, since te OpenCV Python libraries are installed using pip , we need to install python3-pip as well. Finally, pip3 is used to install the opencv-python package that lets us import cv2 . This is not the 'proper' way to install dependencies for a ROS package. You're supposed to define the right dependencies in one of the package files and then use the rosdep tool to install them all. That would play poorly with our Docker approach though, as every change to the code would trigger a re-install and it would all get rather slow. Instead, I've taken the pain of finding the dependencies manually, with a little trial and error, so I can do it just once on first building. This gets into the dark arts of managing a Linux system, which is beyond the scope for learning here. If you want to use some extra software for the project, please just ask staff for help. COPY . /ros_ws/src/fenswood_drone_controller The rest of the file is unchanged from what we provided, but for completeness: this command copies the contents of the local fenswood_drone_controller folder into the container. RUN . /ros_ws/install/setup.sh \\ && colcon build These are the standard commands to build our local ROS package. All the stuff in setup.py is used by the colcon build tool to copy stuff to the right shared folders. CMD [ \"ros2\", \"launch\", \"fenswood_drone_controller\", \"controller.launch.xml\" ] The final line is the command to run when the container is launched, which is to use ROS to run the launch file discussed above, i.e. to run our two nodes. Back to tutorial contents Exercises \u00b6 Add a ROS timer to the image processor node and use it to log the latest received image every half second, rather than every image received. Send a basic message, maybe just a string with some image information, from the image processor to the controller. Log the message on both sides so you can be sure it got through. Do some basic image processing on the received image and re-publish it to a new ROS topic. This tutorial gives some basics like changing a few pixels around or drawing abox round a region. This tutorial shows the syntax for converting an image back from OpenCV to ROS and publishing it. Back to tutorial contents","title":"8. Adding Perception"},{"location":"tutorial/perception/#adding-perception","text":"Back to tutorial contents","title":"Adding perception"},{"location":"tutorial/perception/#introduction","text":"All the other examples in this tutorial focus on controlling the drone. However, you may decide to close the loop on the control problem using some image processing on the camera feed from the drone. This tutorial gives you a framework for doing so using the OpenCV image processing framework. In doing so, you will also learn how to extend the simulation application to: - install third-party libraries and ROS packages, in this case OpenCV and the associated vision_opencv ROS package; and - compile and launch multiple ROS nodes within a modular control system. OpenCV is a free open-source image processing library. It offers a variety of tools for analyzing and manipulating images, nicely wrapped in a nice Python interface, with good tutorials . OpenCV is not part of ROS, but others have done the work to provide a simple 'bridge' for converting ROS image messages to OpenCV and back. There are also various extra tutorials available online, including this one which I relied on to develop this tutorial. OpenCV is not the latest all-singing-all-dancing deep learning vision solution - but it is easy to learn and probably enough for finding big red blobs in a green world. Other tutorials have emphasized the importance of modularity and the same applies here. Each module should do one thing well. Our controller.py script provides a nice, coherent set of drone control capability but it's already getting long. It would be cluttered to try and squeeze image processing into it as well, so this example will put the image processing in another file to be run as another ROS node. Some kind of interface will need to be worked out to share information from the perception node to the controller node - but ROS makes that kind of communication easy. Keeping the two separate also helps development: one team member can work on control while another works on perception, without creating conflicts.","title":"Introduction"},{"location":"tutorial/perception/#software-deployment","text":"The tutorial so far has deliberately hidden a lot of the Starling framework around the controller. You have seen and worked on just the one file controller.py and we have provided some 'magic' that runs that script and a simulator, hooked up together, when you type in that docker-compose... command. Since all we have been changing is the one file, none of the rest of the framework has changed, and that --build bit on the end of the docker-compose... command has made sure to pick up the edited file each time. So far so good, but now we are extending the framework, it is time to look further into the 'magic'. It is covered in depth in the Starling overview chapter of the advanced tutorial but briefly, we will deploy the application shown below: The steps to get perception working are: write the Python code for the image processing tell our fenswood_drone_controller ROS package where to find it extend the launch file so the image processor is started along with the controller make sure the Docker container for the controller has the necessary dependencies installed If you do the advanced tutorial, you will learn a bit more about how all of this works together and how you might be able to do some more complex things! Back to tutorial contents","title":"Software deployment"},{"location":"tutorial/perception/#example-code","text":"To run this example, use docker-compose up --build as before or run the one in the 6_perception directory. The remainder of this section works through each of the steps identified above, corresponding to a particular file.","title":"Example code"},{"location":"tutorial/perception/#writing-the-image-processing-code","text":"A separate file fenswood_drone_controller/fenswood_drone_controller/image_processor.py contained the Python code for doing the image processing, such as it is. Why the repeated name? It happens a lot in Python. The outer directory is the ROS package and the inner one is the Python package. You do need both. import rclpy from rclpy.node import Node from sensor_msgs.msg import Image import cv2 from cv_bridge import CvBridge The first two imports of rclpy and Node are standard ROS stuff and the same as for the controller, as we will be developing a class for our own ROS node. The Image class is the standard ROS message type for sharing images. (Happily for those of us who don't know a MOV from an MPEG, ROS hides all the practical pain of image transport from us.) The cv2 library is the entire OpenCV toolset. Finally CvBridge is the thing that converts a ROS image message to an OpenCV image object, or vice versa . class ImageProcessor(Node): def __init__(self): super().__init__('image_processor') self.br = CvBridge() As for the controller, a new class is defined as a child of the Node class to represent the image processing node. It calls the parent constructor to get ROS set up. The only other thing it does it create a CvBridge for later use doing the conversions. def start(self): # set up subscriber for image state_sub = self.create_subscription(Image, 'camera/image_raw', self.image_callback, 10) The start method will set the node actually working by subscribing to the image topic and running the callback on each response. This node is completely callback-driven so there is nothing else to do here. Note: it's usually a bad idea to do lots of work in callbacks, especially on something quite high-rate like a camera feed. In the exercises, I will ask you to improve upon this. # on receiving image, convert and log information def image_callback(self,msg): img = self.br.imgmsg_to_cv2(msg) # can do OpenCV stuff on img now shp = img.shape # just get the size self.get_logger().info('Got an image of {} x {}'.format(shp[0],shp[1])) The image callback method does very little for now, but enough to see if everything is working. The CvBridge created in __init__ is used to convert the image message to an OpenCV image object. All I do is extract its size using the shape property and log it. def main(args=None): rclpy.init(args=args) image_node = ImageProcessor() image_node.start() rclpy.spin(image_node) if __name__ == '__main__': main() The rest of the file is almost identical to the controller case. The main function creates the node object, starts the subscription, and then uses spin to hand over timing to ROS. The if __name__ ... bit is here out of habit.","title":"Writing the image processing code"},{"location":"tutorial/perception/#telling-ros-where-to-find-it","text":"The setup.py file in the upper fenswood_drone_controller directory tells ROS where to find the bits of Python it might need, including scripts we want to run. It's a clumsy set-up but happily we'll only need to edit part... from setuptools import setup from glob import glob package_name = \"fenswood_drone_controller\" setup( name=package_name, version=\"0.0.0\", packages=[package_name], data_files=[ (\"share/ament_index/resource_index/packages\",[\"resource/\"+package_name]), (\"share/\" + package_name, ['package.xml']), (\"share/\" + package_name, glob('launch/*.launch.*')) ], install_requires=[\"setuptools\"], zip_safe=True, maintainer=\"Robert Clarke\", maintainer_email=\"TODO\", description=\"Example Python controller for Ardupilot at Fenswood\", license=\"TODO\", tests_require=[\"pytest\"], entry_points={ \"console_scripts\": [ \"controller = fenswood_drone_controller.controller:main\", \"controller_old_school = fenswood_drone_controller.controller_old_school:main\", \"controller_simple_class = fenswood_drone_controller.controller_simple_class:main\", \"controller_modular = fenswood_drone_controller.controller_modular:main\", \"controller_finite_state = fenswood_drone_controller.controller_finite_state:main\", \"image_processor = fenswood_drone_controller.image_processor:main\" ] } ) There, that bit right at the end: added to the console_scripts list entry in the entry_points dictionary, the item \"image_processor = fenswood_drone_controller.image_processor:main\" tells ROS that you run an image_processor node by calling the main function in the image_processor module of the fenswood_drone_controller package. Please don't ask the general principles behind this - unless you want to get really into Python and ROS packaging, just follow the pattern.","title":"Telling ROS where to find it"},{"location":"tutorial/perception/#telling-ros-to-run-it","text":"Most ROS applications quickly encounter the need to run multiple collaborating nodes. ROS supports various types of launch file to support running complex combinations of things, perhaps with different configurations, using a single command. You can even write launch files in Python to do clever conditional stuff, but I prefer the basic XML version for a simple job like ours. The (updated) launch file is controller.launch.xml living in the launch subdirectory of the fenswood_drone_controller package directory. Other files are configured to tell ROS where it lives and to tell Docker to run it on starting our container, so we just need to add the perception node to it. <launch> <node pkg=\"fenswood_drone_controller\" exec=\"controller\" /> <node pkg=\"fenswood_drone_controller\" exec=\"image_processor\" /> </launch> It's pretty simple: the whole XML file contains a big <launch> element to which we have added a second <node> subelement asking ROS to run the image_processor node (same name we used in setup.py ) from the fenswood_drone_controller package.","title":"Telling ROS to run it"},{"location":"tutorial/perception/#installing-the-dependecies-on-the-docker-container","text":"Recall that the simulation application is a series of Docker containers running together, like little simulated computers networked together. While four of the five containers involved are pulled pre-built from the cloud, the controller container that runs the controller and image processor is built locally. (That's what the --build thing is about.) The recipe for this container is contained in the Dockerfile in the fenswood_drone_controller directory . Noting that each controller is like its own computer, we need to ensure that computer has OpenCV installed to run our mage processor code. This means editing the Dockerfile as shown below. FROM uobflightlabstarling/starling-controller-base:latest This is the starting point: Starling provides a base recipe (formally an image ) for controller development, which this file will then modify. RUN apt update RUN apt-get install -y ros-foxy-vision-opencv python3-pip RUN pip3 install opencv-python These are the new lines, and they're just like the commands you would type into your Linux computer if you wanted to do this locally. First update the software list, then install the vision_opencv package for ROS2 version foxy . Also, since te OpenCV Python libraries are installed using pip , we need to install python3-pip as well. Finally, pip3 is used to install the opencv-python package that lets us import cv2 . This is not the 'proper' way to install dependencies for a ROS package. You're supposed to define the right dependencies in one of the package files and then use the rosdep tool to install them all. That would play poorly with our Docker approach though, as every change to the code would trigger a re-install and it would all get rather slow. Instead, I've taken the pain of finding the dependencies manually, with a little trial and error, so I can do it just once on first building. This gets into the dark arts of managing a Linux system, which is beyond the scope for learning here. If you want to use some extra software for the project, please just ask staff for help. COPY . /ros_ws/src/fenswood_drone_controller The rest of the file is unchanged from what we provided, but for completeness: this command copies the contents of the local fenswood_drone_controller folder into the container. RUN . /ros_ws/install/setup.sh \\ && colcon build These are the standard commands to build our local ROS package. All the stuff in setup.py is used by the colcon build tool to copy stuff to the right shared folders. CMD [ \"ros2\", \"launch\", \"fenswood_drone_controller\", \"controller.launch.xml\" ] The final line is the command to run when the container is launched, which is to use ROS to run the launch file discussed above, i.e. to run our two nodes. Back to tutorial contents","title":"Installing the dependecies on the Docker container"},{"location":"tutorial/perception/#exercises","text":"Add a ROS timer to the image processor node and use it to log the latest received image every half second, rather than every image received. Send a basic message, maybe just a string with some image information, from the image processor to the controller. Log the message on both sides so you can be sure it got through. Do some basic image processing on the received image and re-publish it to a new ROS topic. This tutorial gives some basics like changing a few pixels around or drawing abox round a region. This tutorial shows the syntax for converting an image back from OpenCV to ROS and publishing it. Back to tutorial contents","title":"Exercises"},{"location":"tutorial/ros_timer/","text":"Using a ROS timer \u00b6 Back to tutorial contents Introduction \u00b6 The controller is now implemented in its own class, a child of the ROS Node class so it's easy to access ROS functionality. Basic drone interactions like mode changes and movement commands are implemented as methods containing the necessary ROS functions. Callback functions record incoming data to properties for other methods to access. A finite state machine manages the decision-making. In this final enhancement, a ROS timer is used to update the finite state machine, making our node in line with established ROS2 best practice. Back to tutorial contents Example code \u00b6 Run the eample using docker-compose -f 5_ros_timer/docker-compose-ros-timer.yml up --build The key file is fenswood_drone_controller/fenswood_drone_controller/controller.py . The remainder of this section describes how it works. import rclpy from rclpy.node import Node # import message definitions for receiving status and position from mavros_msgs.msg import State from sensor_msgs.msg import NavSatFix # import message definition for sending setpoint from geographic_msgs.msg import GeoPoseStamped # import service definitions for changing mode, arming, take-off and generic command from mavros_msgs.srv import SetMode, CommandBool, CommandTOL, CommandLong Imports include rclpy for ROS functions, especially the Node class to be the parent for our controller class. The more specific imports represent the message type for every ROS topic and service that the controller will use. class FenswoodDroneController(Node): def __init__(self): super().__init__('example_controller') self.last_status = None # store for last received status message self.last_pos = None # store for last received position message self.init_alt = None # store for global altitude at start self.last_alt_rel = None # store for last altitude relative to start # and make a placeholder for the last sent target self.last_target = GeoPoseStamped() The contructor __init__ calls the parent constructor to initialize the ROS connections. Properties for shared information are created and (mostly) initialized to None for easy detection of missing data. # create service clients for long command (datastream requests)... self.cmd_cli = self.create_client(CommandLong, 'mavros/cmd/command') # ... for mode changes ... self.mode_cli = self.create_client(SetMode, 'mavros/set_mode') # ... for arming ... self.arm_cli = self.create_client(CommandBool, 'mavros/cmd/arming') # ... and for takeoff self.takeoff_cli = self.create_client(CommandTOL, 'mavros/cmd/takeoff') # create publisher for setpoint self.target_pub = self.create_publisher(GeoPoseStamped, 'mavros/setpoint_position/global', 10) Clients for service calls and target publishing are all created at initialization. Subscribers wait for later though as they start the callbacks running. Note there are no wait_for_service or spin calls here. Using the ROS timer handles all these timing elements for us, and deadlocks can result if extra timing calls are included. # initial state for finite state machine self.control_state = 'init' # timer for time spent in each state self.state_timer = 0 The finite state machine and the state step counter are initialized. def start(self): # set up two subscribers, one for vehicle state... state_sub = self.create_subscription(State, 'mavros/state', self.state_callback, 10) # ...and the other for global position pos_sub = self.create_subscription(NavSatFix, 'mavros/global_position/global', self.position_callback, 10) # create a ROS2 timer to run the control actions self.timer = self.create_timer(1.0, self.timer_callback) A separate start method creates the two topic subscriptions and the timer. Callbacks will start running once this method is called. I like to keep a separate start method in cases like this (instead of putting this in the __init__ constructor function) so you can build a controller object and play with it before it actually does any ROS work. # on receiving status message, save it to global def state_callback(self,msg): self.last_status = msg self.get_logger().debug('Mode: {}. Armed: {}. System status: {}'.format(msg.mode,msg.armed,msg.system_status)) # on receiving positon message, save it to global def position_callback(self,msg): # determine altitude relative to start if self.init_alt: self.last_alt_rel = msg.altitude - self.init_alt self.last_pos = msg self.get_logger().debug('Drone at {}N,{}E altitude {}m'.format(msg.latitude, msg.longitude, self.last_alt_rel)) These are the two callback functions for the drone status and global position topics, respectively. Once that start method has been called and the two subscriptions set up, these will run in their own threads whenever messages are received. def request_data_stream(self,msg_id,msg_interval): cmd_req = CommandLong.Request() cmd_req.command = 511 cmd_req.param1 = float(msg_id) cmd_req.param2 = float(msg_interval) future = self.cmd_cli.call_async(cmd_req) self.get_logger().info('Requested msg {} every {} us'.format(msg_id,msg_interval)) def change_mode(self,new_mode): mode_req = SetMode.Request() mode_req.custom_mode = new_mode future = self.mode_cli.call_async(mode_req) self.get_logger().info('Request sent for {} mode.'.format(new_mode)) def arm_request(self): arm_req = CommandBool.Request() arm_req.value = True future = self.arm_cli.call_async(arm_req) self.get_logger().info('Arm request sent') def takeoff(self,target_alt): takeoff_req = CommandTOL.Request() takeoff_req.altitude = target_alt future = self.takeoff_cli.call_async(takeoff_req) self.get_logger().info('Requested takeoff to {}m'.format(target_alt)) def flyto(self,lat,lon,alt): self.last_target.pose.position.latitude = lat self.last_target.pose.position.longitude = lon self.last_target.pose.position.altitude = alt self.target_pub.publish(self.last_target) self.get_logger().info('Sent drone to {}N, {}E, altitude {}m'.format(lat,lon,alt)) These helper methods wrap up the ROS details for performing common drone actions: request data, change mode, arm, take-off and fly to a location. def state_transition(self): if self.control_state =='init': if self.last_status: if self.last_status.system_status==3: self.get_logger().info('Drone initialized') # send command to request regular position updates self.request_data_stream(33, 1000000) # change mode to GUIDED self.change_mode(\"GUIDED\") # move on to arming return('arming') else: return('init') else: return('init') elif self.control_state == 'arming': if self.last_status.armed: self.get_logger().info('Arming successful') # armed - grab init alt for relative working if self.last_pos: self.last_alt_rel = 0.0 self.init_alt = self.last_pos.altitude # send takeoff command self.takeoff(20.0) return('climbing') elif self.state_timer > 60: # timeout self.get_logger().error('Failed to arm') return('exit') else: self.arm_request() return('arming') elif self.control_state == 'climbing': if self.last_alt_rel > 19.0: self.get_logger().info('Close enough to flight altitude') # move drone by sending setpoint message self.flyto(51.423, -2.671, self.init_alt - 30.0) # unexplained correction factor on altitude return('on_way') elif self.state_timer > 60: # timeout self.get_logger().error('Failed to reach altitude') return('landing') else: self.get_logger().info('Climbing, altitude {}m'.format(self.last_alt_rel)) return('climbing') elif self.control_state == 'on_way': d_lon = self.last_pos.longitude - self.last_target.pose.position.longitude d_lat = self.last_pos.latitude - self.last_target.pose.position.latitude if (abs(d_lon) < 0.0001) & (abs(d_lat) < 0.0001): self.get_logger().info('Close enough to target delta={},{}'.format(d_lat,d_lon)) return('landing') elif self.state_timer > 60: # timeout self.get_logger().error('Failed to reach target') return('landing') else: self.get_logger().info('Target error {},{}'.format(d_lat,d_lon)) return('on_way') elif self.control_state == 'landing': # return home and land self.change_mode(\"RTL\") return('exit') elif self.control_state == 'exit': # nothing else to do return('exit') The state_transition function is called once per control time step. It carries out control tasks, depending on the current state of the controller and the time spent in it so far, and then returns what the next controller state should be. See the finite state machine tutorial for a full discussion of the logic employed. Note : the arming state now sets the last_alt_rel property to zero when arming is successful. We never did this before and got away with it. With the ROS timer managing the update rate, it became possible for the next state transition to run before a new position message had been received, with the result that last_alt_rel was still at its initial None value, causing an error. This just shows how timers and multi-threading require you to be careful about handling every case. def timer_callback(self): new_state = self.state_transition() if new_state == self.control_state: self.state_timer = self.state_timer + 1 else: self.state_timer = 0 self.control_state = new_state self.get_logger().info('Controller state: {} for {} steps'.format(self.control_state, self.state_timer)) The timer_callback function will run automatically at the interval specified when the timer was set up in the start function. It simply calls the state_transition method and then updates the finite state machine, both state and timer. Common finite state stuff like this is therefore kept away from the scenario-specific control logic in state_transition . The latter will evolve as you work on your solution, and it's important to avoid mistakes like forgetting to reset the timer. Note there are no spin or wait calls anywhere in the code so far and the former wait_for_new_status method has gone. The ROS timer now determines when to call te state transition update. This makes the code simpler but can introduce odd behaviour if things don't run in the order you expect, like the last_altitude_rel issue described above. def main(args=None): rclpy.init(args=args) controller_node = FenswoodDroneController() controller_node.start() rclpy.spin(controller_node) The main function is the ROS entry point for the controller ( i.e. what ROS will run for us). It just creates the controller, calls its start to set it running. The spin call then turns execution over to the three threads created: the two callbacks and the timer, and there is nothing left to do in main . The spin call will handle all the necessary timing and just keep the whole thing alive until it is killed by ROS ( e.g. with a Ctrl+C ). if __name__ == '__main__': main() The Python bit on the end will redirect execution to the main function if the file is executed as a script. (I'm not sure it's needed, given we point ROS to main in a different file.) Exercises \u00b6 All exercises involve editing the file fenswood_drone_controller/fenswood_drone_controller/controller.py . Create a method to move the camera. It should publish a message of type std_msgs/Float32 to the /vehicle_1/gimbal_tilt_cmd topic to move the camera, with 0 in the data field being horizontal and 1.57 being straight downwards. Move the camera on reaching the target location. Add a method to measure distance (in some simple way) to the last target. Use it to simplify the code in the state_transition() method. Then add a stage to your code that flies to a second target after the first has been reached. None of the methods in the example so far returned a value! If you include a return x statement in the method, you can use x = self.my_method(stuff) to access it. Use return a,b,c and a,b,c = self.my_method(stuff) to return multiple values , if that's required. Following on from above, change the togic so that you fly to the second target if you run out of time to reach the first. Test by changing the timeout setting and/or moving the first target. You should see your drone fly toward the first target but then divert. Add a request for message 32, LOCAL_POSITION_NED . Observe what happens on foxglove looking at topic /vehicle_1/mavros/local_position/pose . In the code, add a subscriber to /vehicle_1/mavros/local_position/pose and try using this local altitude to track climb progress in run() . Add a human 'approve' input. When you get to altitude, ask the operator (in the log) if they are happy to proceed, and fly to the target only if they approve. For input, you can define your own ROS topic and have them publish through Foxglove, or re-purpose the tele-op gamepad buttons to publish to a different topic, or just ask the operator to wiggle the camera. Test all cases you can think of: operator says 'yes' when asked, operator says 'no' when asked, operator says nothing, operator has said 'yes' but before being asked, etc. Add a human 'pause' input. Define a button, topic or some other signal, and make the drone stop and hover if the operator requests it. There are lots of ways of implementing this, including mode changes or extra control logic. Don't forget you can connect QGroundControl to the simulation via localhost, TCP port 5761, if you want the operator to interact that way. Add a method to send a velocity command by publishing a geomerty_msgs/Twist message to the /vehicle_1/mavros/setpoint_velocity/cmd_vel_unstamped topic. On reaching the target, use this to fly at a constant velocity for ten seconds. The extend your logic so the operator can stop the drone earlier if they choose. Back to tutorial contents","title":"7. Using A Ros Timer"},{"location":"tutorial/ros_timer/#using-a-ros-timer","text":"Back to tutorial contents","title":"Using a ROS timer"},{"location":"tutorial/ros_timer/#introduction","text":"The controller is now implemented in its own class, a child of the ROS Node class so it's easy to access ROS functionality. Basic drone interactions like mode changes and movement commands are implemented as methods containing the necessary ROS functions. Callback functions record incoming data to properties for other methods to access. A finite state machine manages the decision-making. In this final enhancement, a ROS timer is used to update the finite state machine, making our node in line with established ROS2 best practice. Back to tutorial contents","title":"Introduction"},{"location":"tutorial/ros_timer/#example-code","text":"Run the eample using docker-compose -f 5_ros_timer/docker-compose-ros-timer.yml up --build The key file is fenswood_drone_controller/fenswood_drone_controller/controller.py . The remainder of this section describes how it works. import rclpy from rclpy.node import Node # import message definitions for receiving status and position from mavros_msgs.msg import State from sensor_msgs.msg import NavSatFix # import message definition for sending setpoint from geographic_msgs.msg import GeoPoseStamped # import service definitions for changing mode, arming, take-off and generic command from mavros_msgs.srv import SetMode, CommandBool, CommandTOL, CommandLong Imports include rclpy for ROS functions, especially the Node class to be the parent for our controller class. The more specific imports represent the message type for every ROS topic and service that the controller will use. class FenswoodDroneController(Node): def __init__(self): super().__init__('example_controller') self.last_status = None # store for last received status message self.last_pos = None # store for last received position message self.init_alt = None # store for global altitude at start self.last_alt_rel = None # store for last altitude relative to start # and make a placeholder for the last sent target self.last_target = GeoPoseStamped() The contructor __init__ calls the parent constructor to initialize the ROS connections. Properties for shared information are created and (mostly) initialized to None for easy detection of missing data. # create service clients for long command (datastream requests)... self.cmd_cli = self.create_client(CommandLong, 'mavros/cmd/command') # ... for mode changes ... self.mode_cli = self.create_client(SetMode, 'mavros/set_mode') # ... for arming ... self.arm_cli = self.create_client(CommandBool, 'mavros/cmd/arming') # ... and for takeoff self.takeoff_cli = self.create_client(CommandTOL, 'mavros/cmd/takeoff') # create publisher for setpoint self.target_pub = self.create_publisher(GeoPoseStamped, 'mavros/setpoint_position/global', 10) Clients for service calls and target publishing are all created at initialization. Subscribers wait for later though as they start the callbacks running. Note there are no wait_for_service or spin calls here. Using the ROS timer handles all these timing elements for us, and deadlocks can result if extra timing calls are included. # initial state for finite state machine self.control_state = 'init' # timer for time spent in each state self.state_timer = 0 The finite state machine and the state step counter are initialized. def start(self): # set up two subscribers, one for vehicle state... state_sub = self.create_subscription(State, 'mavros/state', self.state_callback, 10) # ...and the other for global position pos_sub = self.create_subscription(NavSatFix, 'mavros/global_position/global', self.position_callback, 10) # create a ROS2 timer to run the control actions self.timer = self.create_timer(1.0, self.timer_callback) A separate start method creates the two topic subscriptions and the timer. Callbacks will start running once this method is called. I like to keep a separate start method in cases like this (instead of putting this in the __init__ constructor function) so you can build a controller object and play with it before it actually does any ROS work. # on receiving status message, save it to global def state_callback(self,msg): self.last_status = msg self.get_logger().debug('Mode: {}. Armed: {}. System status: {}'.format(msg.mode,msg.armed,msg.system_status)) # on receiving positon message, save it to global def position_callback(self,msg): # determine altitude relative to start if self.init_alt: self.last_alt_rel = msg.altitude - self.init_alt self.last_pos = msg self.get_logger().debug('Drone at {}N,{}E altitude {}m'.format(msg.latitude, msg.longitude, self.last_alt_rel)) These are the two callback functions for the drone status and global position topics, respectively. Once that start method has been called and the two subscriptions set up, these will run in their own threads whenever messages are received. def request_data_stream(self,msg_id,msg_interval): cmd_req = CommandLong.Request() cmd_req.command = 511 cmd_req.param1 = float(msg_id) cmd_req.param2 = float(msg_interval) future = self.cmd_cli.call_async(cmd_req) self.get_logger().info('Requested msg {} every {} us'.format(msg_id,msg_interval)) def change_mode(self,new_mode): mode_req = SetMode.Request() mode_req.custom_mode = new_mode future = self.mode_cli.call_async(mode_req) self.get_logger().info('Request sent for {} mode.'.format(new_mode)) def arm_request(self): arm_req = CommandBool.Request() arm_req.value = True future = self.arm_cli.call_async(arm_req) self.get_logger().info('Arm request sent') def takeoff(self,target_alt): takeoff_req = CommandTOL.Request() takeoff_req.altitude = target_alt future = self.takeoff_cli.call_async(takeoff_req) self.get_logger().info('Requested takeoff to {}m'.format(target_alt)) def flyto(self,lat,lon,alt): self.last_target.pose.position.latitude = lat self.last_target.pose.position.longitude = lon self.last_target.pose.position.altitude = alt self.target_pub.publish(self.last_target) self.get_logger().info('Sent drone to {}N, {}E, altitude {}m'.format(lat,lon,alt)) These helper methods wrap up the ROS details for performing common drone actions: request data, change mode, arm, take-off and fly to a location. def state_transition(self): if self.control_state =='init': if self.last_status: if self.last_status.system_status==3: self.get_logger().info('Drone initialized') # send command to request regular position updates self.request_data_stream(33, 1000000) # change mode to GUIDED self.change_mode(\"GUIDED\") # move on to arming return('arming') else: return('init') else: return('init') elif self.control_state == 'arming': if self.last_status.armed: self.get_logger().info('Arming successful') # armed - grab init alt for relative working if self.last_pos: self.last_alt_rel = 0.0 self.init_alt = self.last_pos.altitude # send takeoff command self.takeoff(20.0) return('climbing') elif self.state_timer > 60: # timeout self.get_logger().error('Failed to arm') return('exit') else: self.arm_request() return('arming') elif self.control_state == 'climbing': if self.last_alt_rel > 19.0: self.get_logger().info('Close enough to flight altitude') # move drone by sending setpoint message self.flyto(51.423, -2.671, self.init_alt - 30.0) # unexplained correction factor on altitude return('on_way') elif self.state_timer > 60: # timeout self.get_logger().error('Failed to reach altitude') return('landing') else: self.get_logger().info('Climbing, altitude {}m'.format(self.last_alt_rel)) return('climbing') elif self.control_state == 'on_way': d_lon = self.last_pos.longitude - self.last_target.pose.position.longitude d_lat = self.last_pos.latitude - self.last_target.pose.position.latitude if (abs(d_lon) < 0.0001) & (abs(d_lat) < 0.0001): self.get_logger().info('Close enough to target delta={},{}'.format(d_lat,d_lon)) return('landing') elif self.state_timer > 60: # timeout self.get_logger().error('Failed to reach target') return('landing') else: self.get_logger().info('Target error {},{}'.format(d_lat,d_lon)) return('on_way') elif self.control_state == 'landing': # return home and land self.change_mode(\"RTL\") return('exit') elif self.control_state == 'exit': # nothing else to do return('exit') The state_transition function is called once per control time step. It carries out control tasks, depending on the current state of the controller and the time spent in it so far, and then returns what the next controller state should be. See the finite state machine tutorial for a full discussion of the logic employed. Note : the arming state now sets the last_alt_rel property to zero when arming is successful. We never did this before and got away with it. With the ROS timer managing the update rate, it became possible for the next state transition to run before a new position message had been received, with the result that last_alt_rel was still at its initial None value, causing an error. This just shows how timers and multi-threading require you to be careful about handling every case. def timer_callback(self): new_state = self.state_transition() if new_state == self.control_state: self.state_timer = self.state_timer + 1 else: self.state_timer = 0 self.control_state = new_state self.get_logger().info('Controller state: {} for {} steps'.format(self.control_state, self.state_timer)) The timer_callback function will run automatically at the interval specified when the timer was set up in the start function. It simply calls the state_transition method and then updates the finite state machine, both state and timer. Common finite state stuff like this is therefore kept away from the scenario-specific control logic in state_transition . The latter will evolve as you work on your solution, and it's important to avoid mistakes like forgetting to reset the timer. Note there are no spin or wait calls anywhere in the code so far and the former wait_for_new_status method has gone. The ROS timer now determines when to call te state transition update. This makes the code simpler but can introduce odd behaviour if things don't run in the order you expect, like the last_altitude_rel issue described above. def main(args=None): rclpy.init(args=args) controller_node = FenswoodDroneController() controller_node.start() rclpy.spin(controller_node) The main function is the ROS entry point for the controller ( i.e. what ROS will run for us). It just creates the controller, calls its start to set it running. The spin call then turns execution over to the three threads created: the two callbacks and the timer, and there is nothing left to do in main . The spin call will handle all the necessary timing and just keep the whole thing alive until it is killed by ROS ( e.g. with a Ctrl+C ). if __name__ == '__main__': main() The Python bit on the end will redirect execution to the main function if the file is executed as a script. (I'm not sure it's needed, given we point ROS to main in a different file.)","title":"Example code"},{"location":"tutorial/ros_timer/#exercises","text":"All exercises involve editing the file fenswood_drone_controller/fenswood_drone_controller/controller.py . Create a method to move the camera. It should publish a message of type std_msgs/Float32 to the /vehicle_1/gimbal_tilt_cmd topic to move the camera, with 0 in the data field being horizontal and 1.57 being straight downwards. Move the camera on reaching the target location. Add a method to measure distance (in some simple way) to the last target. Use it to simplify the code in the state_transition() method. Then add a stage to your code that flies to a second target after the first has been reached. None of the methods in the example so far returned a value! If you include a return x statement in the method, you can use x = self.my_method(stuff) to access it. Use return a,b,c and a,b,c = self.my_method(stuff) to return multiple values , if that's required. Following on from above, change the togic so that you fly to the second target if you run out of time to reach the first. Test by changing the timeout setting and/or moving the first target. You should see your drone fly toward the first target but then divert. Add a request for message 32, LOCAL_POSITION_NED . Observe what happens on foxglove looking at topic /vehicle_1/mavros/local_position/pose . In the code, add a subscriber to /vehicle_1/mavros/local_position/pose and try using this local altitude to track climb progress in run() . Add a human 'approve' input. When you get to altitude, ask the operator (in the log) if they are happy to proceed, and fly to the target only if they approve. For input, you can define your own ROS topic and have them publish through Foxglove, or re-purpose the tele-op gamepad buttons to publish to a different topic, or just ask the operator to wiggle the camera. Test all cases you can think of: operator says 'yes' when asked, operator says 'no' when asked, operator says nothing, operator has said 'yes' but before being asked, etc. Add a human 'pause' input. Define a button, topic or some other signal, and make the drone stop and hover if the operator requests it. There are lots of ways of implementing this, including mode changes or extra control logic. Don't forget you can connect QGroundControl to the simulation via localhost, TCP port 5761, if you want the operator to interact that way. Add a method to send a velocity command by publishing a geomerty_msgs/Twist message to the /vehicle_1/mavros/setpoint_velocity/cmd_vel_unstamped topic. On reaching the target, use this to fly at a constant velocity for ten seconds. The extend your logic so the operator can stop the drone earlier if they choose. Back to tutorial contents","title":"Exercises"},{"location":"tutorial/simple_class/","text":"Implementing the controller as a class \u00b6 Back to tutorial contents Introduction \u00b6 We can improve on the ugliness of a monolithic script and global variables using Object-Oriented Programming (OOP). A full introduction to OOP is beyond the scope of this tutorial, so it is expected that you are familiar with the fundamentals: classes, objects, methods, properties, methods and inheritance. By making our controller an object , it is able to share data between its different methods (in the callbacks and the main thread) without using ugly global variables. Furthermore, we can make our controller a child of the ROS Node class which tidies up a lot of ROS interaction, inspired by the minimal ROS examples . Back to tutorial contents Example code \u00b6 To run this example: docker-compose -f docker-compose-simple-class.yml up --build The key file is fenswood_drone_controller/fenswood_drone_controller/controller_simple_class.py subdirectory. The remainder of this section describes how it works. Only differences from the old school are covered and details may refer back to explanations in that example. import rclpy from rclpy.node import Node # import message definitions for receiving status and position from mavros_msgs.msg import State from sensor_msgs.msg import NavSatFix # import message definition for sending setpoint from geographic_msgs.msg import GeoPoseStamped # import service definitions for changing mode, arming, take-off and generic command from mavros_msgs.srv import SetMode, CommandBool, CommandTOL, CommandLong The initial imports are the same as before , with the exception of the extra import of the Node class from rclpy which we will use as the parent of our controller. class FenswoodDroneController(Node): Straight into the definition of our custom FenswoodDroneController class which will be a child of the ROS Node class. This means it will have all the same methods and properties as a Node , plus any extra we add and any changes we make by overloading. def __init__(self): super().__init__('example_controller') The __init__ function (the constructor) of the parent Node class is called explicitly, setting any FenswoodDroneController up as a ROS Node with the name provided. self.last_state = None # global for last received status message self.last_pos = None # global for last received position message self.init_alt = None # global for global altitude at start self.last_alt_rel = None # global for last altitude relative to start Stores for information shared between different parts of the class are initialized here as properties of the controller, referenced by the self keywords. These relate one-to-one with the old global variables but will be local to the controller object. Thus if we ever made more than one controller node, each would have its own data: much better! # on receiving status message, save it to global def state_callback(self,msg): self.last_state = msg self.get_logger().debug('Mode: {}. Armed: {}. System status: {}'.format(msg.mode,msg.armed,msg.system_status)) # on receiving positon message, save it to global def position_callback(self,msg): # determine altitude relative to start if self.init_alt: self.last_alt_rel = msg.altitude - self.init_alt self.last_pos = msg self.get_logger().debug('Drone at {}N,{}E altitude {}m'.format(msg.latitude, msg.longitude, self.last_alt_rel)) The callbacks are defined as methods of the FenswoodDroneController class, as they are indented to be part of the class definition. They therefore have access to the properties via the self command and we don't need any nasty global stuff. The functionalisyt is the same as before: just save the messages as they come in, and calculate a relative altitude if an initial altitude has been set. def wait_for_new_status(self): if self.last_state: # if had a message before, wait for higher timestamp last_stamp = self.last_state.header.stamp.sec for try_wait in range(60): rclpy.spin_once(self) if self.last_state.header.stamp.sec > last_stamp: break else: for try_wait in range(60): if self.last_state: break rclpy.spin_once(self) The wait_for_new_status function is unchanged, save for becoming a method. As before, if a previous status message has been received, wait for a newer one, otherwise wait for the first one. def run(self): # set up two subscribers, one for vehicle state... state_sub = self.create_subscription(State, 'mavros/state', self.state_callback, 10) # ...and the other for global position pos_sub = self.create_subscription(NavSatFix, 'mavros/global_position/global', self.position_callback, 10) The run method executes all the control activities (like the former main function). It starts by subscribing to the state and global position topics. Note: you could put the subscribers in the __init__ function, and the functionality of the code would be identical in this example. However, I always prefer to put subscribers in a separate run or start method. That way, you can instantiate an object from the controller class without firing up all the callbacks, which is helpful if you sometimes want to do other tasks separate to the control work. Because our class is a child of the Node class, methods of that parent class can be accessed via self , such as self.create_subscription . # first wait for the system status to become 3 \"standby\" # see https://mavlink.io/en/messages/common.html#MAV_STATE for try_standby in range(60): self.wait_for_new_status() if self.last_state.system_status==3: self.get_logger().info('Drone ready for flight') break # send command to request regular position updates cmd_req = CommandLong.Request() cmd_req.command = 511 cmd_req.param1 = float(33) # msg ID for position is 33 \\ # https://mavlink.io/en/messages/common.html#GLOBAL_POSITION_INT cmd_req.param2 = float(1000000) # 1000000 micro-second interval : 1Hz rate cmd_cli = self.create_client(CommandLong, 'mavros/cmd/command') while not cmd_cli.wait_for_service(timeout_sec=1.0): self.get_logger().info('command_int service not available, waiting again...') future = cmd_cli.call_async(cmd_req) rclpy.spin_until_future_complete(self, future) # wait for response self.get_logger().info('Requested position stream') # now change mode to GUIDED mode_req = SetMode.Request() mode_req.custom_mode = \"GUIDED\" mode_cli = self.create_client(SetMode, 'mavros/set_mode') while not mode_cli.wait_for_service(timeout_sec=1.0): self.get_logger().info('set_mode service not available, waiting again...') future = mode_cli.call_async(mode_req) rclpy.spin_until_future_complete(self, future) # wait for response self.get_logger().info('Request sent for GUIDED mode.') # next, try to arm the drone arm_req = CommandBool.Request() arm_req.value = True arm_cli = self.create_client(CommandBool, 'mavros/cmd/arming') while not arm_cli.wait_for_service(timeout_sec=1.0): self.get_logger().info('arming service not available, waiting again...') # keep trying until arming detected in state message, or 60 attempts for try_arm in range(60): future = arm_cli.call_async(arm_req) rclpy.spin_until_future_complete(self, future) self.get_logger().info('Arming request sent.') self.wait_for_new_status() if self.last_state.armed: self.get_logger().info('Arming successful') # armed - grab init alt for relative working if self.last_pos: self.init_alt = self.last_pos.altitude break else: self.get_logger().error('Failed to arm') # take off and climb to 20.0m at current location takeoff_req = CommandTOL.Request() takeoff_req.altitude = 20.0 takeoff_cli = self.create_client(CommandTOL, 'mavros/cmd/takeoff') while not takeoff_cli.wait_for_service(timeout_sec=1.0): self.get_logger().info('takeoff service not available, waiting again...') # only call once - seems to work OK future = takeoff_cli.call_async(takeoff_req) rclpy.spin_until_future_complete(self, future) self.get_logger().info('Takeoff request sent.') # wait for drone to reach desired altitude, or 60 attempts for try_alt in range(60): self.wait_for_new_status() self.get_logger().info('Climbing, altitude {}m'.format(self.last_alt_rel)) if self.last_alt_rel > 19.0: self.get_logger().info('Close enough to flight altitude') break # move drone by sending setpoint message target_msg = GeoPoseStamped() target_msg.pose.position.latitude = 51.423 target_msg.pose.position.longitude = -2.671 target_msg.pose.position.altitude = self.init_alt - 30.0 # unexplained correction factor target_pub = self.create_publisher(GeoPoseStamped, 'mavros/setpoint_position/global', 10) self.wait_for_new_status() # short delay after creating publisher ensures message not lost target_pub.publish(target_msg) self.get_logger().info('Sent drone to {}N, {}E, altitude {}m'.format(target_msg.pose.position.latitude, target_msg.pose.position.longitude, target_msg.pose.position.altitude)) # wait for drone to reach desired position, or timeout after 60 attempts for try_arrive in range(60): self.wait_for_new_status() d_lon = self.last_pos.longitude - target_msg.pose.position.longitude d_lat = self.last_pos.latitude - target_msg.pose.position.latitude self.get_logger().info('Target error {},{}'.format(d_lat,d_lon)) if abs(d_lon) < 0.0001: if abs(d_lat) < 0.0001: self.get_logger().info('Close enough to target delta={},{}'.format(d_lat,d_lon)) break # return home and land mode_req.custom_mode = \"RTL\" future = mode_cli.call_async(mode_req) rclpy.spin_until_future_complete(self, future) # wait for response self.get_logger().info('Request sent for RTL mode.') # now just serve out the time until process killed while rclpy.ok(): rclpy.spin_once(self) The rest of this method is almost identical to the old school example but with the globals replaced by the properties. Note also extensive use of the Node methods, e.g. self.get_logger() or self.create_publisher() . def main(args=None): rclpy.init(args=args) controller_node = FenswoodDroneController() controller_node.run() We still have to have a main function as the entry point for the script, but now it just creates a new object of the FenswoodDroneController class and then executes its run() method. if __name__ == '__main__': main() The above is the same 'Python thing' as before, redirecting to the main function if this file is executed as a script. Exercises \u00b6 All exercises involve editing the file fenswood_drone_controller/fenswood_drone_controller/controller_simple_class.py Move the camera. Publish a message of type std_msgs/Float32 to the /vehicle_1/gimbal_tilt_cmd topic to move the camera, with 0 in the data field being horizontal and 1.57 being straight downwards. Back to tutorial contents","title":"4. Implementing the contorller as a class"},{"location":"tutorial/simple_class/#implementing-the-controller-as-a-class","text":"Back to tutorial contents","title":"Implementing the controller as a class"},{"location":"tutorial/simple_class/#introduction","text":"We can improve on the ugliness of a monolithic script and global variables using Object-Oriented Programming (OOP). A full introduction to OOP is beyond the scope of this tutorial, so it is expected that you are familiar with the fundamentals: classes, objects, methods, properties, methods and inheritance. By making our controller an object , it is able to share data between its different methods (in the callbacks and the main thread) without using ugly global variables. Furthermore, we can make our controller a child of the ROS Node class which tidies up a lot of ROS interaction, inspired by the minimal ROS examples . Back to tutorial contents","title":"Introduction"},{"location":"tutorial/simple_class/#example-code","text":"To run this example: docker-compose -f docker-compose-simple-class.yml up --build The key file is fenswood_drone_controller/fenswood_drone_controller/controller_simple_class.py subdirectory. The remainder of this section describes how it works. Only differences from the old school are covered and details may refer back to explanations in that example. import rclpy from rclpy.node import Node # import message definitions for receiving status and position from mavros_msgs.msg import State from sensor_msgs.msg import NavSatFix # import message definition for sending setpoint from geographic_msgs.msg import GeoPoseStamped # import service definitions for changing mode, arming, take-off and generic command from mavros_msgs.srv import SetMode, CommandBool, CommandTOL, CommandLong The initial imports are the same as before , with the exception of the extra import of the Node class from rclpy which we will use as the parent of our controller. class FenswoodDroneController(Node): Straight into the definition of our custom FenswoodDroneController class which will be a child of the ROS Node class. This means it will have all the same methods and properties as a Node , plus any extra we add and any changes we make by overloading. def __init__(self): super().__init__('example_controller') The __init__ function (the constructor) of the parent Node class is called explicitly, setting any FenswoodDroneController up as a ROS Node with the name provided. self.last_state = None # global for last received status message self.last_pos = None # global for last received position message self.init_alt = None # global for global altitude at start self.last_alt_rel = None # global for last altitude relative to start Stores for information shared between different parts of the class are initialized here as properties of the controller, referenced by the self keywords. These relate one-to-one with the old global variables but will be local to the controller object. Thus if we ever made more than one controller node, each would have its own data: much better! # on receiving status message, save it to global def state_callback(self,msg): self.last_state = msg self.get_logger().debug('Mode: {}. Armed: {}. System status: {}'.format(msg.mode,msg.armed,msg.system_status)) # on receiving positon message, save it to global def position_callback(self,msg): # determine altitude relative to start if self.init_alt: self.last_alt_rel = msg.altitude - self.init_alt self.last_pos = msg self.get_logger().debug('Drone at {}N,{}E altitude {}m'.format(msg.latitude, msg.longitude, self.last_alt_rel)) The callbacks are defined as methods of the FenswoodDroneController class, as they are indented to be part of the class definition. They therefore have access to the properties via the self command and we don't need any nasty global stuff. The functionalisyt is the same as before: just save the messages as they come in, and calculate a relative altitude if an initial altitude has been set. def wait_for_new_status(self): if self.last_state: # if had a message before, wait for higher timestamp last_stamp = self.last_state.header.stamp.sec for try_wait in range(60): rclpy.spin_once(self) if self.last_state.header.stamp.sec > last_stamp: break else: for try_wait in range(60): if self.last_state: break rclpy.spin_once(self) The wait_for_new_status function is unchanged, save for becoming a method. As before, if a previous status message has been received, wait for a newer one, otherwise wait for the first one. def run(self): # set up two subscribers, one for vehicle state... state_sub = self.create_subscription(State, 'mavros/state', self.state_callback, 10) # ...and the other for global position pos_sub = self.create_subscription(NavSatFix, 'mavros/global_position/global', self.position_callback, 10) The run method executes all the control activities (like the former main function). It starts by subscribing to the state and global position topics. Note: you could put the subscribers in the __init__ function, and the functionality of the code would be identical in this example. However, I always prefer to put subscribers in a separate run or start method. That way, you can instantiate an object from the controller class without firing up all the callbacks, which is helpful if you sometimes want to do other tasks separate to the control work. Because our class is a child of the Node class, methods of that parent class can be accessed via self , such as self.create_subscription . # first wait for the system status to become 3 \"standby\" # see https://mavlink.io/en/messages/common.html#MAV_STATE for try_standby in range(60): self.wait_for_new_status() if self.last_state.system_status==3: self.get_logger().info('Drone ready for flight') break # send command to request regular position updates cmd_req = CommandLong.Request() cmd_req.command = 511 cmd_req.param1 = float(33) # msg ID for position is 33 \\ # https://mavlink.io/en/messages/common.html#GLOBAL_POSITION_INT cmd_req.param2 = float(1000000) # 1000000 micro-second interval : 1Hz rate cmd_cli = self.create_client(CommandLong, 'mavros/cmd/command') while not cmd_cli.wait_for_service(timeout_sec=1.0): self.get_logger().info('command_int service not available, waiting again...') future = cmd_cli.call_async(cmd_req) rclpy.spin_until_future_complete(self, future) # wait for response self.get_logger().info('Requested position stream') # now change mode to GUIDED mode_req = SetMode.Request() mode_req.custom_mode = \"GUIDED\" mode_cli = self.create_client(SetMode, 'mavros/set_mode') while not mode_cli.wait_for_service(timeout_sec=1.0): self.get_logger().info('set_mode service not available, waiting again...') future = mode_cli.call_async(mode_req) rclpy.spin_until_future_complete(self, future) # wait for response self.get_logger().info('Request sent for GUIDED mode.') # next, try to arm the drone arm_req = CommandBool.Request() arm_req.value = True arm_cli = self.create_client(CommandBool, 'mavros/cmd/arming') while not arm_cli.wait_for_service(timeout_sec=1.0): self.get_logger().info('arming service not available, waiting again...') # keep trying until arming detected in state message, or 60 attempts for try_arm in range(60): future = arm_cli.call_async(arm_req) rclpy.spin_until_future_complete(self, future) self.get_logger().info('Arming request sent.') self.wait_for_new_status() if self.last_state.armed: self.get_logger().info('Arming successful') # armed - grab init alt for relative working if self.last_pos: self.init_alt = self.last_pos.altitude break else: self.get_logger().error('Failed to arm') # take off and climb to 20.0m at current location takeoff_req = CommandTOL.Request() takeoff_req.altitude = 20.0 takeoff_cli = self.create_client(CommandTOL, 'mavros/cmd/takeoff') while not takeoff_cli.wait_for_service(timeout_sec=1.0): self.get_logger().info('takeoff service not available, waiting again...') # only call once - seems to work OK future = takeoff_cli.call_async(takeoff_req) rclpy.spin_until_future_complete(self, future) self.get_logger().info('Takeoff request sent.') # wait for drone to reach desired altitude, or 60 attempts for try_alt in range(60): self.wait_for_new_status() self.get_logger().info('Climbing, altitude {}m'.format(self.last_alt_rel)) if self.last_alt_rel > 19.0: self.get_logger().info('Close enough to flight altitude') break # move drone by sending setpoint message target_msg = GeoPoseStamped() target_msg.pose.position.latitude = 51.423 target_msg.pose.position.longitude = -2.671 target_msg.pose.position.altitude = self.init_alt - 30.0 # unexplained correction factor target_pub = self.create_publisher(GeoPoseStamped, 'mavros/setpoint_position/global', 10) self.wait_for_new_status() # short delay after creating publisher ensures message not lost target_pub.publish(target_msg) self.get_logger().info('Sent drone to {}N, {}E, altitude {}m'.format(target_msg.pose.position.latitude, target_msg.pose.position.longitude, target_msg.pose.position.altitude)) # wait for drone to reach desired position, or timeout after 60 attempts for try_arrive in range(60): self.wait_for_new_status() d_lon = self.last_pos.longitude - target_msg.pose.position.longitude d_lat = self.last_pos.latitude - target_msg.pose.position.latitude self.get_logger().info('Target error {},{}'.format(d_lat,d_lon)) if abs(d_lon) < 0.0001: if abs(d_lat) < 0.0001: self.get_logger().info('Close enough to target delta={},{}'.format(d_lat,d_lon)) break # return home and land mode_req.custom_mode = \"RTL\" future = mode_cli.call_async(mode_req) rclpy.spin_until_future_complete(self, future) # wait for response self.get_logger().info('Request sent for RTL mode.') # now just serve out the time until process killed while rclpy.ok(): rclpy.spin_once(self) The rest of this method is almost identical to the old school example but with the globals replaced by the properties. Note also extensive use of the Node methods, e.g. self.get_logger() or self.create_publisher() . def main(args=None): rclpy.init(args=args) controller_node = FenswoodDroneController() controller_node.run() We still have to have a main function as the entry point for the script, but now it just creates a new object of the FenswoodDroneController class and then executes its run() method. if __name__ == '__main__': main() The above is the same 'Python thing' as before, redirecting to the main function if this file is executed as a script.","title":"Example code"},{"location":"tutorial/simple_class/#exercises","text":"All exercises involve editing the file fenswood_drone_controller/fenswood_drone_controller/controller_simple_class.py Move the camera. Publish a message of type std_msgs/Float32 to the /vehicle_1/gimbal_tilt_cmd topic to move the camera, with 0 in the data field being horizontal and 1.57 being straight downwards. Back to tutorial contents","title":"Exercises"}]}